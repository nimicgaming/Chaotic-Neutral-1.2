<!-- public/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Chaotic Neutral ‚Äî Game</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Minimal styles for the floating Play button (most styles live in style.css) */
    #playFloat {
      position:absolute; display:none; z-index:60;
      transform: translate(-50%, -8px);
      padding:6px 10px; border-radius:999px; border:1px solid #7a5d12;
      background:#ffd772; color:#2a1b00; font-weight:900; font-size:12px;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      cursor:pointer; pointer-events:auto;
    }
  
.token.invisible-to-enemy {
  opacity: 0;
  pointer-events: none;
}
.token.invisible-own {
  opacity: 0.35;
}
.charCard.invisible-own {
  opacity: 0.65;
}

/* === Entangle overlay (vine) === */

.token.entangled::after{
  content:"";
  position:absolute; inset:-4px;
  background: url('/assets/Icons/Vines.png') center/contain no-repeat;
  pointer-events:none;
  opacity:0.95;
  animation: vineSway 2.5s ease-in-out infinite;
}

/* === Entangle vines overlay element (explicit element, not pseudo) === */
.token .vinesOverlay{
  position:absolute; left:-4px; top:-4px; right:-4px; bottom:-4px;
  background: url('/assets/Icons/Vines.png') center/contain no-repeat;
  pointer-events:none;
  z-index: 8;
  opacity: 0.98;
  animation: vineSway 2.5s ease-in-out infinite;
}
@keyframes vineSway{
  0%{ transform: rotate(0deg) scale(1); }
/* === Trapped (Bear Trap caught) overlay on token === */
.token.trapped::after{
  content:"";
  position:absolute; left:-4px; top:-4px; right:-4px; bottom:-4px;
  background: url('/assets/Icons/BearTrapCaught.png') center/contain no-repeat;
  pointer-events:none;
  opacity:0.98;
}
/* Explicit caught overlay element (mirrors vines overlay approach) */
.token img.overlay-trapcaught{
  position:absolute; left:-4px; top:-4px; right:-4px; bottom:-4px;
  pointer-events:none;
  z-index: 999; /* above token content */
}


  50%{ transform: rotate(1deg) scale(1.02); }
  100%{ transform: rotate(0deg) scale(1); }
}


/* === Bear Trap overlay === */
#trapOverlayLayer{
  position:absolute; left:0; top:0; right:0; bottom:0;
  pointer-events:none; z-index:3;
}
.trap-overlay{
  position:absolute; width:104px; height:104px;
  margin-left:-52px; margin-top:-52px;
  background:center/contain no-repeat;
  background-image:url('/assets/Icons/BearTrap.png');
  pointer-events:none;
}

/* === Bear Trap CAUGHT overlay (above tokens) === */
#trapCaughtLayer{
  position:absolute; left:0; top:0; right:0; bottom:0;
  pointer-events:none; z-index:1001; /* above tokens and above trapOverlayLayer */
}
.trap-caught{
  position:absolute; width:104px; height:104px;
  margin-left:-52px; margin-top:-52px;
  background:center/contain no-repeat;
  background-image:url('/assets/Icons/BearTrapCaught.png');
  pointer-events:none;
}
</style>

  <style>
    .top-home-btn{
      position:fixed; left:900px; top:8px; z-index:1000;
      background:#2a2019; color:#ffe29a; border:1px solid #ffffff22;
      padding:6px 10px; border-radius:10px; font:600 14px system-ui; text-decoration:none;
      box-shadow:0 2px 6px rgba(0,0,0,.3);
    }
    .top-home-btn:hover{ filter:brightness(1.1); }
  </style>

  <style>
    /* Parchment full-viewport background */
    html, body { height: 100%; }
    html { background-color: #111 !important; }
    body { background: transparent !important; }
  </style>




<!-- === Map Rotation: Snow / Fairy Grove / Meadow (deterministic per room) === -->
<script>
(function(){
  var CHOICES = [
    "assets/background_snowmeadow.png",
    "assets/background_fairymeadow.png",
    "assets/background_meadow.png"
  ];
  function hash32(str){
    var h = 0;
    for (var i=0;i<str.length;i++){ h = Math.imul(31,h) + str.charCodeAt(i) | 0; }
    return (h>>>0);
  }
  var qs   = new URLSearchParams(location.search);
  var room = qs.get("room") || sessionStorage.getItem("cn_room") || localStorage.getItem("cn_room") || "default";
  var idx  = hash32(String(room)) % CHOICES.length;
  var IMG  = CHOICES[idx];
  window.__cnSelectedMap = IMG;

  function applyBg(){
    try{
      document.documentElement.style.setProperty(
        'background',
        "#111 url('" + IMG + "') center / cover no-repeat fixed",
        'important'
      );
      document.body && document.body.style && document.body.style.setProperty('background', 'transparent', 'important');
    }catch(_){}
  }
  applyBg();

  ['load','focus','visibilitychange','resize'].forEach(function(ev){
    window.addEventListener(ev, applyBg, {passive:true});
  });
  try{
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        if (muts[i].type === 'attributes' && muts[i].attributeName === 'style'){
          var cur = String(document.documentElement.style.background || '');
          if (cur.indexOf(IMG) === -1){ applyBg(); }
        }
      }
    });
    obs.observe(document.documentElement, { attributes:true, attributeFilter:['style'] });
  }catch(_){}
  var _t = setInterval(applyBg, 500);
  setTimeout(function(){ clearInterval(_t); }, 12000);
})();
</script>


<style id="bgmToggleOnBoard">
  /* Anchor the volume slider to the board (same place as the old button) */
  #board { position: relative !important; }
  #board #volWrap{
    position: absolute !important;
    top: 3px;
    right: 285px;
    z-index: 120 !important;
    display:flex; align-items:center; gap:8px;
    padding: 8px 12px; border-radius:16px;
    border:1px solid #ffffff33; background:#1d120bcc; color:#efe6d8;
    box-shadow:0 4px 10px rgba(0,0,0,.35);
    font-weight:900; font-size:16px;
  }
  #board #volWrap input[type="range"]{ width: 90px; }
</style>

<script id="noZoom">
(function(){
  window.addEventListener('wheel', function(e){
    if (e.ctrlKey || e.metaKey) e.preventDefault();
  }, { passive:false });
  window.addEventListener('keydown', function(e){
    if ((e.ctrlKey||e.metaKey) && ['+','=','-','_','0'].includes(e.key)) e.preventDefault();
  }, { passive:false });
  window.addEventListener('gesturestart', function(e){ e.preventDefault(); }, { passive:false });
  window.addEventListener('gesturechange', function(e){ e.preventDefault(); }, { passive:false });
  window.addEventListener('gestureend', function(e){ e.preventDefault(); }, { passive:false });
})();
</script>
</head>
<body>
<script>
// === Voice lines (client-only) ===
const VOICES = {
  NectarOfLife: (() => {
    const a = new Audio('/assets/Sounds/Voice%20Lines/NectarOfLife.mp3'); // encode space
    a.preload = 'auto';
    a.volume = 0.2;
    return a;
  })(),

Trickster_Sleight_A: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/IsThisYourCard.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),
Trickster_Sleight_B: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/WYLTSAMT.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Trickster_Swap: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/Abracadabra.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Loadstone_ReversePolarity: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/ReversePolarity.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Loadstone_PolarAttraction: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/PolarAttraction.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

DungeonMaster_1D6: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/1d6.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

DungeonMaster_SkillCheck: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/skillcheck.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

LittleBear_Transform: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/transform.mp3');
  a.preload = 'auto';
  a.volume = 0.3;
  return a;
})(),

DonAtore_BloodDonation: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/blooddonation.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

DonAtore_Replenish: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/replenish.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Aimbot_FMJ: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/fmj.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Aimbot_TrueShot: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/trueshot.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Voodoo_VoodooDoll: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/voodoodoll.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

Voodoo_Pincushion: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/pincushion.mp3');
  a.preload = 'auto';
  a.volume = 0.1;
  return a;
})(),

LittleBear_PawSwipe: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/pawswipe.mp3');
  a.preload = 'auto';
  a.volume = 0.3;
  return a;
})(),

DeathBlossom_HealingBlossom: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/HealingBlossom.mp3');
  a.preload = 'auto';
  a.volume = 0.2;
  return a;
})(),

LittleBear_BearClaw: (()=>{
  const a = new Audio('/assets/Sounds/Voice%20Lines/bearclaw.mp3');
  a.preload = 'auto';
  a.volume = 0.3;
  return a;
})(),

  DeathBlossom_HealingBlossom: (()=>{
    const a = new Audio('/assets/Sounds/Voice%20Lines/HealingBlossom.mp3');
    a.preload = 'auto';
    a.volume = 0.2;
    return a;
  })(),

  DungeonMaster_SavingThrow: (()=>{
    const a = new Audio('/assets/Sounds/Voice%20Lines/savingthrow.mp3');
    a.preload = 'auto';
    a.volume = 1.0;
    return a;
  })()
};

// --- Fix: Healing Blossom voiceline alias (added by ChatGPT) ---
try { VOICES.HealingBlossom = VOICES.HealingBlossom || VOICES.DeathBlossom_HealingBlossom; } catch (_) {}
function playVoice(key){
  const a = VOICES[key];
  if (!a) return;
  try {
    const mult = (typeof window.__CN_VOL === 'number' ? window.__CN_VOL : 1);
    if (a.__baseVol == null) a.__baseVol = (typeof a.volume === 'number' ? a.volume : 1);
    a.volume = Math.max(0, Math.min(1, a.__baseVol * mult));
    a.pause(); a.currentTime = 0;
    a.muted = false; a.play().catch(()=>{});
  } catch(_){}
}

</script>
<div id="seriesScoreTop" class="glass"><div class="label">Control Points</div><div class="score"><span id="seriesP1">0</span> ‚Äî <span id="seriesP2">0</span></div></div>
  <div id="stage">
    <div id="board">
    <div id="volWrap" class="volWrap" style="display:none">
  <input id="volSlider" type="range" min="0" max="2" step="0.01" value="1" aria-label="Volume">
  <span id="volLabel">Sounds</span>
</div>
    <a id="btnHome" href="/home">‚üµ Home</a>

    <div class="center-dot"></div>
    <div id="boardShadow" aria-hidden="true"></div>

    <div id="label1" class="tag" style="display:none"></div>
    <div id="label2" class="tag" style="display:none"></div>
    <div id="turn-popup">Your Turn</div>

    <div id="allyPanel" class="panel"></div>
    <div id="enemyPanel" class="panel"></div>

    <!-- [ENERGY] Player energy bar -->
    <div  id="energyBox" class="glass">
      <div class="label">Energy</div>
      <div class="energybar"><div class="fill" style="width:0%"></div></div>
      <div class="energyNums"><span id="energyVal">0</span> / <span id="energyMax">10</span></div>
    </div>

    <div id="controlScoreBox" class="glass" style="display:none">
      <div class="score"><span id="p1Score">0</span> ‚Äî <span id="p2Score">0</span></div>
    </div>


    <!-- Hand: centered at bottom -->
    <div id="handWrap">
      <div id="hand" class="glass"></div>
    </div>

    <!-- Discards -->
    <div id="discardSelf" class="glass discardBox">
      <div class="label">Your Discard</div>
      <div class="slot" id="discardSelfSlot">‚Äî</div>
    </div>
    <div id="discardOther" class="glass discardBox">
      <div class="label">Opponent Discard</div>
      <div class="slot" id="discardOtherSlot">‚Äî</div>
    </div>

    <button  id="end-turn">End Turn</button>

    <div id="gameover">
      <div class="box">
        <h1 id="wintext">Game Over</h1>
        <p id="winsub">Winner: ‚Äî</p>
      </div>
    </div>
  </div>
  </div>

  <!-- Floating Play button (positioned by JS just above the selected card) -->
  <button id="playFloat">Play</button>

  
  <!-- === BGM (match start) === -->
  <audio id="bgmAudio" src="assets/Sounds/Music/Song1.mp3" preload="auto" loop></audio>
  

  <script src="/socket.io/socket.io.js"></script>
<script>


// === Swap interaction (client) ===
window.canSwap = false;
window.swapSourceId = null;

// Click any token to be swap target when canSwap is active
document.addEventListener('click', (e) => {
  const tokenEl = e.target.closest('.token');
  if (!tokenEl) return;
  const targetId = tokenEl.dataset.id;
  if (!window.canSwap || !window.swapSourceId || !targetId || targetId === window.swapSourceId) return;
  try {
    if (typeof socket !== 'undefined') {
      socket.emit('useSpecial', { sourceId: window.swapSourceId, targetId });
    }
  } finally {
    window.canSwap = false;
    window.swapSourceId = null;
  }
});


</script>
  <script>
    /* --------- Room / join wiring --------- */
    const params = new URLSearchParams(location.search);
    const ROOM = params.get('room') || sessionStorage.getItem('cn_room') || localStorage.getItem('cn_room');
    if (!ROOM){ location.href = '/home'; }
    const PLAYER_NAME = sessionStorage.getItem('cn_name') || localStorage.getItem('cn_name') || '';
    const HEROES = JSON.parse(sessionStorage.getItem('cn_roster') || localStorage.getItem('cn_roster') || '[]');
    const MODE = (new URLSearchParams(location.search).get('mode') || sessionStorage.getItem('cn_mode') || localStorage.getItem('cn_mode') || 'standard');
    /* hide control UI when not in control mode */
    if (MODE !== 'control') {
      const top = document.getElementById('seriesScoreTop'); if (top) top.remove();
      const box = document.getElementById('controlScoreBox'); if (box) box.remove();
    }

    sessionStorage.setItem('cn_mode', MODE); localStorage.setItem('cn_mode', MODE);

    const socket = io();
    socket.emit('game:join', { room: ROOM, name: PLAYER_NAME, heroes: HEROES, mode: MODE });

    /* ---------- DOM ---------- */
    const board   = document.getElementById('board');
    const wallOverlayLayer = document.createElement('div');
    wallOverlayLayer.id = 'wallOverlayLayer';
    board.appendChild(wallOverlayLayer);

    
    // Trap overlay layer (for Bear Trap icons)
    const trapOverlayLayer = document.createElement('div');
    trapOverlayLayer.id = 'trapOverlayLayer';
    board.appendChild(trapOverlayLayer);

    // Caught overlay layer (above tokens)
    const trapCaughtLayer = document.createElement('div');
    trapCaughtLayer.id = 'trapCaughtLayer';
    board.appendChild(trapCaughtLayer);
// Control Points overlay + flag
    const controlOverlayLayer = document.createElement('div');
    controlOverlayLayer.id = 'controlOverlayLayer';
    board.appendChild(controlOverlayLayer);
    const controlFlag = document.createElement('div');
    controlFlag.id = 'controlFlag';
    controlFlag.innerHTML = '<svg id="controlFlagSVG" viewBox="0 0 48 64" xmlns="http://www.w3.org/2000/svg">\
  <rect x="6" y="6" width="5" height="52" fill="#171717" rx="2" />\
  <path d="M12 10 L44 20 L12 30 Z" fill="#e33" stroke="#b00" stroke-width="2" />\
</svg>';
    controlFlag.style.display = 'none';
    board.appendChild(controlFlag);

    const wallOverlays = new Map();

    const hand    = document.getElementById('hand');
    const endBtn  = document.getElementById('end-turn');
    const banner  = document.getElementById('turn-popup');
    const label1  = document.getElementById('label1');
    const label2  = document.getElementById('label2');
    const allyPanel  = document.getElementById('allyPanel');
    const enemyPanel = document.getElementById('enemyPanel');
    const gameover  = document.getElementById('gameover');
    const wintext   = document.getElementById('wintext');
    const winsub    = document.getElementById('winsub');
    const discardSelfSlot  = document.getElementById('discardSelfSlot');
    const discardOtherSlot = document.getElementById('discardOtherSlot');
    const playFloat = document.getElementById('playFloat');

    let GAME_ENDED = false;

    /* ---------- UI placement helpers ---------- */
    
    // Guard to prevent random drift from non-resize interactions
    let __allowRepositionEndBtn = false;
    function placeEndButton(force=false){
      if (!force && !__allowRepositionEndBtn) return;
      const boardRect = board.getBoundingClientRect();
      const handRect  = hand.getBoundingClientRect();
      const btnRect   = endBtn.getBoundingClientRect();
      const gap = 16;
      let left = (handRect.left - boardRect.left) - btnRect.width - gap;
      if (left < 12) left = 12;
      }
    window.addEventListener('resize', ()=>{ /* keep HUD fixed */ if (selectedCard) positionPlayFloat(selectedCard); });
    
    let __allowRepositionEnergy = false;
    function positionEnergyBox(force=false){
      if (!force && !__allowRepositionEnergy) return;
      const ally = document.getElementById('allyPanel');
      const energy = document.getElementById('energyBox');
      const handWrap = document.getElementById('handWrap');
      if (!ally || !energy) return;
      const ar = ally.getBoundingClientRect();
      const hr = handWrap ? handWrap.getBoundingClientRect() : { top: window.innerHeight };
      const ebh = energy.offsetHeight || 66;
      const left = Math.round(ar.right + 10);
      let top = Math.round(ar.top + ar.height * 0.655);
      const maxTop = hr.top - ebh - 16;
      const minTop = ar.top + 20;
      top = Math.max(minTop, Math.min(maxTop, top));
      }
    window.addEventListener('resize', ()=>{ /* keep HUD fixed */ });
    /* ---------- Board geometry ---------- */
    const centerX = 960, centerY = 540 - 50;
    const hexR = 58, hexW = Math.sqrt(3) * hexR, hexH = 2 * hexR, vSpace = 0.75 * hexH;
    const rows = [
      { label:'A', count:4 }, { label:'B', count:5 }, { label:'C', count:6 },
      { label:'D', count:7 }, { label:'E', count:8 }, { label:'F', count:7 },
      { label:'G', count:6 }, { label:'H', count:5 }, { label:'I', count:4 }
    ];
    const centerRow = Math.floor(rows.length/2);
    const tilePositions = {};
    rows.forEach((row, ri) => {
      const y = centerY + (ri - centerRow) * vSpace;
      const half = (row.count - 1) * hexW / 2;
      for (let i = 0; i < row.count; i++) {
        const x = centerX - half + i * hexW;
        const id = `${row.label}${i+1}`;
        tilePositions[id] = { x, y };
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.style.left = `${x}px`;
        tile.style.top  = `${y}px`;
        tile.dataset.id = id;
        board.appendChild(tile);
      }
    });

    /* ---------- Adjacency ---------- */
    const adjacency = {};
    const dHoriz = hexW, dVert = vSpace, dDiag = Math.hypot(hexW/2, vSpace);
    const targets = [dHoriz, dVert, dDiag], tol = 0.18;
    (function buildAdj(){
      const ids = Object.keys(tilePositions);
      for (const id of ids){
        const a = tilePositions[id];
        const n = [];
        for (const id2 of ids){
          if (id2 === id) continue;
          const b = tilePositions[id2];
          const dist = Math.hypot(a.x - b.x, a.y - b.y);
          for (const t of targets){ if (Math.abs(dist - t) <= t*tol){ n.push([id2, dist]); break; } }
        }
        n.sort((p,q)=>p[1]-q[1]);
        adjacency[id] = n.slice(0,6).map(p=>p[0]);
      }
    })();
    const neighbors = id => adjacency[id] ?? [];

    function areaWithin(start, range=1, blockedSet){
      const seen = new Set([start]);
      const q = [[start,0]];
      const out = new Set();
      while(q.length){
        const [cur, d] = q.shift();
        if (d > range) continue;
        if (d>0) out.add(cur);
        if (d === range) continue;
        for (const n of neighbors(cur)){
          if (blockedSet && blockedSet.has(n)) continue;
          if (!seen.has(n)){ seen.add(n); q.push([n, d+1]); }
        }
      }
      return [...out];
    }
    function reachable(start, steps=1, blockedSet){ return areaWithin(start, steps, blockedSet); }

    function shortestDistanceWithWalls(start, goal, blockedSet){
      if (start === goal) return 0;
      const seen = new Set([start]);
      const q = [[start,0]];
      while(q.length){
        const [cur,d] = q.shift();
        for (const nxt of neighbors(cur)){
          if (blockedSet && blockedSet.has(nxt)) continue;
          if (seen.has(nxt)) continue;
          if (nxt === goal) return d+1;
          seen.add(nxt); q.push([nxt, d+1]);
        }
      }
      return Infinity;
    }

    /* ---------- Turn / Role ---------- */
    let playerRole = null;
    let currentTurn = 'player1';
    let turnState = { usedMovement:false, usedAction:false, cardPlayed:false };
    function setBanner(){ banner.style.display = (!GAME_ENDED && playerRole === currentTurn) ? 'block' : 'none'; }

    const mirror = (x,y)=>({ x: centerX - (x - centerX), y: centerY - (y - centerY) });
    const toScreen = (x,y)=> (playerRole === 'player2') ? mirror(x,y) : {x,y};
    const toLogical = (sx,sy)=> (playerRole === 'player2') ? mirror(sx,sy) : {x:sx, y:sy};

    function nearestTile(x,y){
      let best=Infinity, bestId=null, bestPos=null;
      for (const [id,p] of Object.entries(tilePositions)){
        const d = (x-p.x)**2 + (y-p.y)**2;
        if (d < best){ best=d; bestId=id; bestPos=p; }
      }
      return { id: bestId, ...bestPos };
    }
    function occupied(tileId, except=null){
      return Array.from(document.querySelectorAll('.token'))
        .some(t => t !== except && t.dataset.tile === tileId);
    }

    /* ---------- Highlights ---------- */
    const ghosts = [];
    // Global fallback: ensure a top-level function exists for drag handlers
    if (typeof window.clearNonBlossomGhosts !== 'function'){
      window.clearNonBlossomGhosts = function(){
        try {
          for (let i = ghosts.length - 1; i >= 0; i--){
            const el = ghosts[i];
            if (!el || !el.classList) continue;
            const keep = el.classList.contains('blossom') || el.classList.contains('blossom-pink') ||
                         el.classList.contains('enemy-blossom') || el.classList.contains('enemy-blossom-pink');
            if (!keep){ ghosts.splice(i,1); el.remove(); }
          }
        } catch(e){ clearGhosts(); }
      };
    }

    
    function clearGhosts(){ while (ghosts.length) ghosts.pop().remove(); }
    // Remove only red attack overlays, preserve blossom walls/auras
    function clearAttackGhosts(){
      for (let i = ghosts.length - 1; i >= 0; i--){
        const el = ghosts[i];
        if (el && el.classList && el.classList.contains('attack')){
          ghosts.splice(i,1);
          el.remove();
        }
      }
    }
function addGhost(tileId, className=''){
      const p = tilePositions[tileId];
      const s = toScreen(p.x,p.y);
      const g = document.createElement('div');
      g.className = 'ghost' + (className ? (' '+className) : '');
      g.style.left = `${s.x}px`;
      g.style.top  = `${s.y}px`;
      g.title = tileId;
      board.appendChild(g);
      ghosts.push(g);
    }
    function highlightSet(tileIds, cls){
      clearGhosts();
      for (const t of tileIds) addGhost(t, cls);
    }

    
    // Mirror of entangle-vines reconcile: apply/remove .trapped class based on statusFX
    function __reconcileTrappedOverlayFromStatus(){
      try{
        document.querySelectorAll('.token').forEach(tok=>{
          const id = String(tok.dataset.id||"");
          const fx = statusFX.get(id) || {};
          const hasTrap = !!(fx.trapped && Number(fx.trapped) > 0);
          if (hasTrap){
            tok.classList.add('trapped');
            tok.dataset.rooted = "true";
            tok.classList.add('rooted');
          }else{
            tok.classList.remove('trapped');
            // only clear rooted if not entangled either
            const fxe = statusFX.get(id) || {};
            const stillEnt = !!(fxe.entangle && Number(fxe.entangle) > 0);
            if (!stillEnt){
              tok.dataset.rooted = "false";
              tok.classList.remove('rooted');
            }
          }
        });
      }catch(_){}
    }
    /* ---------- Local board/card state ---------- */
    window.scopeBonusNext = 0;
    /* [ENERGY] Local energy snapshot + UI */
    let energyBySeat = { player1:0, player2:0 };
    function myEnergy(){ return energyBySeat[playerRole] || 0; }
    function updateEnergyBar(val, max=10){
      energyBySeat[playerRole] = val;
      const box = document.getElementById('energyBox');
      const fill = box.querySelector('.energybar .fill');
      const valEl = document.getElementById('energyVal');
      const maxEl = document.getElementById('energyMax');
      const pct = Math.max(0, Math.min(100, (val/max)*100));
      fill.style.width = pct + '%';
      valEl.textContent = String(val|0);
      maxEl.textContent = String(max|0);
    }
    function flashEnergyNotEnough(){
      const box = document.getElementById('energyBox'); if (!box) return;
      box.classList.add('pulse');
      setTimeout(()=> box.classList.remove('pulse'), 600);
    }

    const localWalls = new Set();
    let selectedCard = null;
    let playedCardThisTurn = false;
    let cardArmed = false;
    let armedCardName = null;
    let simpleTarget = null; // { card: 'Fireball' | 'Entangle' | 'Iron Skin' } // requires board selection after pressing Play (wall/quake/teleport)
    let moveBuff = { stepsBonus:0, minSteps:0 }; // client preview; server authoritative
    let moveBuffOnce = false; // true when Sprint was played; clear after first local move

    function applyWallLocal(tileId){ localWalls.add(tileId); addGhost(tileId, 'block wall persist'); showWallOverlay(tileId); }
    function removeWallLocal(tileId){ localWalls.delete(tileId); [...document.querySelectorAll('.ghost.block.wall')].filter(g=>g.title===tileId).forEach(el=>el.remove()); hideWallOverlay(tileId); }
    
    // ===== Overlay wall helpers (independent of ghost system) =====
    function showWallOverlay(tileId){
      if (wallOverlays.has(tileId)) return;
      const el = document.createElement('div');
      el.className = 'wall-overlay';
      el.title = tileId;
      const pos = tilePositions[tileId];
      if (pos){
        const s = toScreen(pos.x, pos.y);
        el.style.left = s.x + 'px';
        el.style.top  = s.y + 'px';
      }
      wallOverlayLayer.appendChild(el);
      wallOverlays.set(tileId, el);
    }
    function hideWallOverlay(tileId){
      const el = wallOverlays.get(tileId);
      if (el){ el.remove(); wallOverlays.delete(tileId); }
    }
    function reconcileWallOverlays(blockedList){
      const keep = new Set((blockedList||[]).map(w=> (w && (w.tile||w))));
      // remove old overlays not present anymore
      for (const tid of Array.from(wallOverlays.keys())){
        if (!keep.has(tid)) hideWallOverlay(tid);
      }
      // add overlays missing
      for (const tid of keep){
        showWallOverlay(tid);
      }
    }
    
    // ===== Trap overlays (Bear Trap) =====
    const localTraps = new Set();
    const trapTilesAnyOwner = new Set(); // hidden knowledge: all trap tiles, used to reveal on trigger to both clients
    const trapOverlays = new Map();
    let __turnTick = 0; // increments on every nextTurn
    const trapPlacedAtTick = new Map(); // tileId -> tick when shown
    const trapSuppressedLocal = new Set(); // tiles whose trap icon we purposely hid (TTL), don't re-add in reconcile
    const trapTTL = new Map();
    function showTrapOverlay(tileId){
      if (trapOverlays.has(tileId)) return;
      const el = document.createElement('div');
      el.className = 'trap-overlay';
      el.title = tileId;
      const pos = tilePositions[tileId];
      if (pos){
        const s = toScreen(pos.x, pos.y);
        el.style.left = s.x + 'px';
        el.style.top  = s.y + 'px';
      }
      trapOverlayLayer.appendChild(el);
      trapOverlays.set(tileId, el); try{ if(!trapTTL.has(tileId)) trapTTL.set(tileId, 4); }catch(_){ } try{ if(!trapPlacedAtTick.has(tileId)) trapPlacedAtTick.set(tileId, __turnTick); }catch(_){ }
    }
    function hideTrapOverlay(tileId){
      const el = trapOverlays.get(tileId);
      if (el){ el.remove(); trapOverlays.delete(tileId); try{ trapTTL.delete(tileId); }catch(_){ } try{ trapPlacedAtTick.delete(tileId); }catch(_){ } }
    }
    // === Bear Trap CAUGHT helpers ===
const trapCaughtOverlays = new Map();
    const trapCaughtTTL = new Map();
    const trapCaughtTileByUnit = new Map(); // unitId -> tileId for caught overlay cleanup
function showTrapCaughtOverlay(tileId){
  if (trapCaughtOverlays.has(tileId)) return;
  const el = document.createElement('div');
  el.className = 'trap-caught';
  el.title = tileId;
  const pos = tilePositions[tileId];
  if (pos){
    const s = toScreen(pos.x, pos.y);
    el.style.left = s.x + 'px';
    el.style.top  = s.y + 'px';
  }
  trapCaughtLayer.appendChild(el);
  trapCaughtOverlays.set(tileId, el); try{ if(!trapCaughtTTL.has(tileId)) trapCaughtTTL.set(tileId, 4); }catch(_){ }
}
// --- FORCE show caught at tile using absolute coordinates (ignores wrappers) ---
function FORCE_showTrapCaughtAtTile(tileId){
  try{
    if (!tileId) return;
    // Don't duplicate
    try{ if (typeof trapCaughtOverlays!=='undefined' && trapCaughtOverlays.has(String(tileId))) return; }catch(_){}
    const pos = tilePositions[String(tileId)];
    if (!pos || typeof toScreen!=='function') return;
    const s = toScreen(pos.x, pos.y);
    const el = document.createElement('div');
    el.className = 'trap-caught';
    el.style.left = s.x + 'px';
    el.style.top  = s.y + 'px';
    try{
      if (typeof trapCaughtLayer!=='undefined' && trapCaughtLayer && trapCaughtLayer.appendChild){
        trapCaughtLayer.appendChild(el);
      } else {
        const host = document.getElementById('trapCaughtLayer') || document.body;
        host.appendChild(el);
      }
    }catch(_){}
    try{ if (typeof trapCaughtOverlays!=='undefined' && trapCaughtOverlays.set) trapCaughtOverlays.set(String(tileId), el); }catch(_){}
  }catch(_){}
}

function hideTrapCaughtOverlay(tileId){
  const el = trapCaughtOverlays.get(tileId);
  if (el){ el.remove(); trapCaughtOverlays.delete(tileId); try{ trapCaughtTTL.delete(tileId); }catch(_){ } }
}

function applyTrapLocal(tileId){ localTraps.add(tileId); try{ trapSuppressedLocal.delete && trapSuppressedLocal.delete(tileId); }catch(_){ } showTrapOverlay(tileId);
  }
    function removeTrapLocal(tileId){ localTraps.delete(tileId); hideTrapOverlay(tileId);
  }
    function reconcileTrapOverlays(trapList){const keep = new Set((trapList||[]).filter(t=>t && t.owner===playerRole).map(t=> (t&&(t.tile||t))));
      // exclude locally suppressed
      try{ if (trapSuppressedLocal) { for (const tid of Array.from(trapSuppressedLocal.values())) keep.delete(tid); } }catch(_){ }
      
      // TTL / tick filter - do not show expired traps
      try{
        for (const tid of Array.from(keep.values())){
          const ttl = (typeof trapTTL!=='undefined' && trapTTL && trapTTL.get) ? trapTTL.get(tid) : null;
          const placed = (typeof trapPlacedAtTick!=='undefined' && trapPlacedAtTick && trapPlacedAtTick.get) ? trapPlacedAtTick.get(tid) : null;
          const expired = ((ttl!==null && ttl<=0) || (typeof placed==='number' && (typeof __turnTick!=='undefined') && ((__turnTick - (placed|0)) >= 4)));
          if (expired){ keep.delete(tid); try{ trapSuppressedLocal && trapSuppressedLocal.add && trapSuppressedLocal.add(tid); }catch(_){} try{ hideTrapOverlay(tid); }catch(_){} try{ trapTTL && trapTTL.delete && trapTTL.delete(tid); }catch(_){} try{ trapPlacedAtTick && trapPlacedAtTick.delete && trapPlacedAtTick.delete(tid); }catch(_){} }
        }
      }catch(_){}
      /* TTL filter */
for (const tid of Array.from(trapOverlays.keys())){
        if (!keep.has(tid)) hideTrapOverlay(tid);

      }for (const tid of keep){ showTrapOverlay(tid);
  }
    }

    const localBlossomWalls = new Set();
    function applyBlossomWallLocal(tileId){ localBlossomWalls.add(tileId); addGhost(tileId, 'block blossom'); }
    function removeBlossomWallLocal(tileId){ localBlossomWalls.delete(tileId); [...document.querySelectorAll('.ghost.block.blossom')].filter(g=>g.title===tileId).forEach(el=>el.remove()); }
    const localBlossomPinkWalls = new Set();
    function applyBlossomPinkWallLocal(tileId){ localBlossomPinkWalls.add(tileId); addGhost(tileId, 'block blossom-pink'); }
    function removeBlossomPinkWallLocal(tileId){ localBlossomPinkWalls.delete(tileId); [...document.querySelectorAll('.ghost.block.blossom-pink')].filter(g=>g.title===tileId).forEach(el=>el.remove()); }

    const enemyBlossomWalls = new Set();
    function applyEnemyBlossomWallLocal(tileId){ enemyBlossomWalls.add(tileId); addGhost(tileId, 'block enemy-blossom'); }
    function removeEnemyBlossomWallLocal(tileId){ enemyBlossomWalls.delete(tileId); [...document.querySelectorAll('.ghost.block.enemy-blossom')].filter(g=>g.title===tileId).forEach(el=>el.remove()); }
    const enemyBlossomPinkWalls = new Set();
    function applyEnemyBlossomPinkWallLocal(tileId){ enemyBlossomPinkWalls.add(tileId); addGhost(tileId, 'block enemy-blossom-pink'); }
    function removeEnemyBlossomPinkWallLocal(tileId){ enemyBlossomPinkWalls.delete(tileId); [...document.querySelectorAll('.ghost.block.enemy-blossom-pink')].filter(g=>g.title===tileId).forEach(el=>el.remove()); }
    
    /* ---------- Ability defs (match server) ---------- */
    const ABIL_DEFS = {
      Tank:    { emoji:'üõ°Ô∏è', color:'#6aa84f', maxHp:18,
                 primary:{type:'damage', dmg:3, range:1, name:'Shield Bash'}, special:{type:'damage', dmg:5, range:1, name:'Hammer Slam'} },
      DPS1:    { emoji:'üê≤', color:'#e06666', maxHp:12,
                 primary:{type:'damage', dmg:3, range:2, name:'Fire Bolt'}, special:{type:'damage', dmg:4, range:2, name:'Dragon‚Äôs Fury'} },
      DPS2:    { emoji:'üó°Ô∏è', color:'#f6b26b', maxHp:11,
                 primary:{type:'damage', dmg:3, range:1, name:'Dagger Thrust'}, special:{type:'damage', dmg:5, range:1, name:'Sneak Attack'} },
      Support: { emoji:'üåø', color:'#93c47d', maxHp:13,
                 primary:{type:'heal', heal:3, range:2, name:'Mend'}, special:{type:'heal', heal:4, range:2, name:'Healing Bloom'} }
    }


    /* --- Per-hero overrides (client) --- */
    
    /* Map character names to portrait images in /public/assets/Character Images */
    function imagePathForName(name){
      const map = {
    "Dungeon Master": "assets/Character Images/Dungeon_Master.png",
        "Voodoo": "assets/Character Images/Voodoo.png",
        "Trickster": "assets/Character Images/Trickster.png",
        "Aimbot": "assets/Character Images/Aimbot.png",
        "Death Blossom": "assets/Character Images/Death_Blossom.png",
        "Loadstone": "assets/Character Images/Loadstone.png","Little Bear": "assets/Character Images/Little_Bear.png",
        "Don Atore": "assets/Character Images/Don_Atore.png"
      };
      return map[name] || null;
    }
const ABIL_OVERRIDES = {
  "Little Bear": { emoji:"üêª", color:"#a36f3f", maxHp:13, primary:{ type:"damage", dmg:3, range:1, name:"Paw Swipe" }, special:{ name:"Transform", type:"transform", energyCost:5, autoSelf:true } },
  "Dungeon Master": {
    emoji:'üé≤', color:'#8e7cc3', maxHp:12,
    primary:{ type:'damage', dmg:'1d6', range:2, name:'1D6' },
    special:{ type:'buff', name:'Skill Check', range:2, energyCost:3 }
  },
      "Death Blossom": {
        emoji:'üå∏',
        color:'#93c47d',
        maxHp:10,
        primary:{ type:'heal', heal:2, range:2, name:'Nectar of Life' },
        special:{ type:'petal', heal:3, range:99, radius:1, name:'Healing Blossom', energyCost:4 }
      },

      Trickster: {
        emoji:'üÉè',
        color:'#f1c232',
        maxHp:11,
        primary:{ type:'damage', dmg:4, range:1, name:'Sleight of Hand' },
        special:{ type:'swap',   range:99, name:'Swap', energyCost:4 }
      },
      Voodoo: {
        emoji:'üßø',
        color:'#b56576',
        // if maxHp not set, Tank base (18) is used
        primary:{ type:'damage', dmg:4, range:1, name:'Pin Cushion' },
        special:{ type:'redirect', name:'Voodoo Doll', energyCost:3, range:0, duration:2, autoSelf:true }
      },
      Aimbot: {
        emoji:'ü§ñ',
        color:'#a3c4f3',
        maxHp:8,
        primary:{ type:'damage', dmg:5, range:3, name:'True Shot' },
        special:{ type:'fmj',    range:4, name:'FMJ', energyCost:6 }
      },
      "Loadstone": {
        emoji:'üß≤',
        color:'#6aa84f',
        maxHp:15,
        primary:{ type:'aoe',    dmg:2, range:1, name:'Reverse Polarity', autoSelf:true },
        special:{ type:'polar',  range:2, name:'Polar Attraction', energyCost:4, autoSelf:true }
      }
      
,
"Don Atore": {
  emoji:"ü©∏",
  color:"#b22222",
  maxHp:12,
  movement:2,
  primary:{ type:'tapHeal', name:'Blood Donation', range:1 },
  special:{ type:"selfHeal", heal:5, range:0, name:"Replenish", energyCost:5, autoSelf:true }
}
};
    function getMeta(role, name){
      const base = ABIL_DEFS[role] || ABIL_DEFS.Tank;
      const ov = name && ABIL_OVERRIDES[name];
      if (!ov) return base;
      return {
        ...base,
        maxHp: ov.maxHp ?? base.maxHp,
        primary: { ...(base.primary||{}), ...(ov.primary||{}) },
        special: { ...(base.special||{}), ...(ov.special||{}) },
        emoji: ov.emoji || base.emoji,
        color: ov.color || base.color
      };
    }
;

    /* ---------- Character STATE ---------- */
    const charState = new Map();
    function initCharIfMissing(id, roleGuess, ownerGuess, nameGuess){
      if (charState.has(id)) return;
      const role = roleGuess || guessRoleFromId(id);
      const def = getMeta(role, nameGuess);
      charState.set(id, { role, owner: ownerGuess || null, hp:def.maxHp, maxHp:def.maxHp, cds:{ special:0 }, dead:false, name:nameGuess||id });
    }
    function setHP(id, hp){
      if (!charState.has(id)) initCharIfMissing(id);
      const s = charState.get(id);
      s.hp = Math.max(0, Math.min(s.maxHp, hp));
      s.dead = (s.hp <= 0);
    }
    function getRoleState(id){ initCharIfMissing(id); return charState.get(id).role; }

    /* ---------- Tokens ---------- */
    /* ---------- Status FX (UI only) ---------- */
    const STATUS_EMOJI = { fireDot:'üî•', ironSkin:'üõ°Ô∏è', entangle:'üçÉ', redirect:'üßø' , trapped:'ü™§', skillCheck:'üé≤', bear:'üêª', invisible:'üëª' };
    const STATUS_DEFAULT_TURNS = { fireDot:3, ironSkin:2, entangle:2, redirect:2 , skillCheck:1 , invisible:2 , trapped:2 };
    const statusFX = new Map(); // id -> { fireDot:n, ironSkin:n, entangle:n }
      // Track who was entangled via the Entangle card (not traps)
      const entangledByCard = new Set();
    // Track last movement by char id for trap correlation
    const lastMoveToTile = new Map();
    const lastMoveAt = new Map();


    
    function updatePrimaryDesc(id){
      const card = document.querySelector(`.charCard[data-id="${id}"]`);
      if (!card) return;
      const nameEl = card.querySelector('.charName');
      const displayName = (charState.get(id)||{}).name || (nameEl ? nameEl.textContent.trim() : '');
      const fx = statusFX.get(String(id)) || {};
      let text;
      if (displayName === 'Little Bear' && fx.bear && Number(fx.bear) > 0){
        text = 'Bear Claw: 5 dmg (range 1)';
      }else{
        const role = getRoleState(id) || guessRoleFromId(id);
        const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : (ABIL_DEFS[role]||ABIL_DEFS.Tank));
        if (!meta || !meta.primary) return;
        if (displayName === 'Don Atore' && meta.primary && meta.primary.type === 'tapHeal'){
          const r = meta.primary.range ?? 1;
          const txt = `${meta.primary.name}: -1HP for +1HP (R${r})`;
          const firstLine = card.querySelector('.desc .descLine:first-child');
          if (firstLine) firstLine.textContent = txt;
          return;
        }
                const isHeal = (meta.primary.type === 'heal');
let amt;
if (displayName === 'Don Atore' && isHeal && meta.primary.selfLossEqual === true){
  // shorter copy per request
  text = `${meta.primary.name}: -1HP for +1HP (R${meta.primary.range})`;
  return;
} else {
  amt = isHeal ? `${meta.primary.heal} heal` : `${meta.primary.dmg} dmg`;
}
text = `${meta.primary.name}: ${amt} (range ${meta.primary.range})`;
      }
      const firstLine = card.querySelector('.desc .descLine:first-child');
      if (firstLine) firstLine.textContent = text;
    }
    function entangleEmojiFor(id){
      try{
        if (typeof trapCaughtTileByUnit !== 'undefined' &&
            trapCaughtTileByUnit && trapCaughtTileByUnit.has(String(id))) {
          return 'ü™§';
        }
      }catch(_){}
      return 'üçÉ';
    }
    

function renderStatusRow(id){
      const card = document.querySelector(`.charCard[data-id="${id}"]`);
      if (!card) return;
      const row = card.querySelector('.statusRow');
      if (!row) return;
      const fx = statusFX.get(id) || {};
      const entries = Object.entries(fx).filter(([,v])=>v>0);
      // === Mirror entangle overlay onto the character CARD ===
      (function(){
        const cardEl = card;
        if (!cardEl) return;
        let vines = cardEl.querySelector('.vinesOverlay');
        const ent = Number(fx && fx.entangle || 0) > 0;
        if (ent){
          if (!vines){
            vines = document.createElement('div');
            vines.className = 'vinesOverlay';
            cardEl.appendChild(vines);
          } else if (vines.parentNode !== cardEl){
            cardEl.appendChild(vines);
          }
        } else if (vines){
          vines.remove();
        }
      })();

      if (!entries.length){ row.innerHTML = ''; return; }
      row.innerHTML = entries.map(([k,v]) => {
        const emoji = (k === 'entangle') ? entangleEmojiFor(id) : (STATUS_EMOJI[k] || '‚Ä¢');
        return `<span class="statusPill" data-k="${k}"><span class="em">${emoji}</span><span class="num">${v}</span></span>`;
      }).join('');
      try{ updatePrimaryDesc(String(id)); }catch(e){}
    }
    function applyStatusFX(fxMap){
      statusFX.clear();
      if (fxMap){
        for (const [id, obj] of Object.entries(fxMap)){
          statusFX.set(String(id), { ...obj });
        }
      }
      document.querySelectorAll('.charCard').forEach(c=>{
        renderStatusRow(c.dataset.id);
      });
      try{
        if (fxMap){
          for (const [id, obj] of Object.entries(fxMap)){
            if (false && obj && obj.entangle){ /* patched: disable heuristic */
              const key = String(id);
              const t = lastMoveToTile.get(key);
              const when = lastMoveAt.get(key);
              const now = Date.now();
              if (t && when && (now - when) < 5000){
                if (typeof showTrapCaughtOverlay === 'function' && !trapCaughtOverlays.has(t)) showTrapCaughtOverlay(t); try{ trapCaughtTileByUnit.set(String(id), t); }catch(_){}
              }
            }
          }
        }
      }catch(_){}
      
      /* Force BearTrapCaught overlay when 'trapped' status is present */
      try{
        if (fxMap){
          for (const [id, obj] of Object.entries(fxMap)){
            const key = String(id);
            const isTrapped = !!(obj && obj.trapped && Number(obj.trapped) > 0);
            const existing = (typeof trapCaughtTileByUnit!=='undefined' && trapCaughtTileByUnit && trapCaughtTileByUnit.get) ? trapCaughtTileByUnit.get(key) : null;
            if (isTrapped){
              // Prefer the unit's current tile
              let tileId = null;
              const tok = document.querySelector(`.token[data-id="${key}"]`);
              if (tok && tok.dataset && tok.dataset.tile) tileId = String(tok.dataset.tile);
              if (!tileId && typeof lastMoveToTile!=='undefined' && lastMoveToTile) tileId = String(lastMoveToTile.get(key)||'');
              if (tileId){
                if (typeof showTrapCaughtOverlay==='function' && !trapCaughtOverlays.has(tileId)) showTrapCaughtOverlay(tileId);
                try{ trapCaughtTileByUnit.set(key, tileId); }catch(_){}
              }
            }else{
              // No longer trapped: remove any caught overlay tied to this unit
              if (existing){ try{ hideTrapCaughtOverlay(existing); }catch(_){ } try{ trapCaughtTileByUnit.delete(key); }catch(_){ } }
            }
          }
        }
      }catch(_){}
    try{ __reconcileEntangleVinesFromCard(); }catch(_){/* noop */}
      try{ __reconcileTrappedOverlayFromStatus(); }catch(_){}

    }
    function addOrUpdateStatusLocal(id, kind, turns){
      try{
        if (false && kind === 'entangle'){ /* patched: disable heuristic */
          const key = String(id);
          const t = lastMoveToTile.get(key);
          const when = lastMoveAt.get(key);
          const now = Date.now();
          if (t && when && (now - when) < 5000){
            if (typeof showTrapCaughtOverlay === 'function' && !trapCaughtOverlays.has(t)) { showTrapCaughtOverlay(t); try{ trapCaughtTileByUnit.set(String(id), t); }catch(_){ } }
          }
        }
      }catch(_){}
    
      if (!id) return;
      const cur = statusFX.get(String(id)) || {};
      cur[kind] = Math.max(turns ?? STATUS_DEFAULT_TURNS[kind] ?? 1, cur[kind]||0);
      statusFX.set(String(id), cur);
      renderStatusRow(String(id)); try{ __reconcileTrappedOverlayFromStatus(); }catch({}){}
      try{
        if (kind === 'trapped'){
          // Determine the unit's current tile and force the caught overlay
          let tileId = null;
          const tok = document.querySelector(`.token[data-id="${String(id)}"]`);
          if (tok && tok.dataset && tok.dataset.tile) tileId = String(tok.dataset.tile);
          if (!tileId && typeof lastMoveToTile!=='undefined' && lastMoveToTile) tileId = String(lastMoveToTile.get(String(id))||'');
          if (tileId){
            if (typeof showTrapCaughtOverlay==='function' && !trapCaughtOverlays.has(tileId)) showTrapCaughtOverlay(tileId);
            try{ trapCaughtTileByUnit.set(String(id), tileId); }catch(_){}
          }
        }
      }catch(_){}
    
    }

    function tokenPortraitFor(id){
      const el = document.querySelector(`.charCard[data-id="${id}"] .charPortrait`);
      return el ? el.textContent.trim() : '‚óè';
    }
    function spawnToken(id, tileId, owner){
      const p = tilePositions[tileId];
      const s = toScreen(p.x,p.y);
      const t = document.createElement('div');
      t.className = 'token';
      t.dataset.id = id;
      t.dataset.owner = owner;
      t.dataset.tile = tileId;
      t.dataset.hasMoved = "false";
      t.innerHTML = `<div class="portrait">${tokenPortraitFor(id)}</div>`;
      t.style.left = `${s.x}px`;
      t.style.top  = `${s.y}px`;
      if (playerRole === owner && !GAME_ENDED) makeDraggable(t);
      board.appendChild(t);
      refreshDraggables();
    }
    function spawnAllFromState(tokensState){
      const keep = new Set(Object.keys(tokensState));
      document.querySelectorAll('.token').forEach(n=>{ if (!keep.has(n.dataset.id)) n.remove(); });
      for (const [id, t] of Object.entries(tokensState)){
        let el = document.querySelector(`.token[data-id="${id}"]`);
        if (!el){
          spawnToken(id, t.tile, t.owner);
          el = document.querySelector(`.token[data-id="${id}"]`);
        }else{
          el.dataset.tile = t.tile;
          const p = tilePositions[t.tile], s = toScreen(p.x,p.y);
          el.style.left = `${s.x}px`; el.style.top = `${s.y}px`;
        }
      }
      refreshDraggables();
    }

    const pendingMoves = new Map(); // id -> previous tile id

    function makeDraggable(token){
      token.addEventListener('mousedown', ()=>{
        if (token.dataset.rooted === "true") return;
        if (GAME_ENDED) return;
        if (playerRole !== currentTurn) return;
        if (token.dataset.owner !== playerRole) return;
        if (turnState.usedMovement) return;

        const hasMoved = token.dataset.hasMoved === "true";
        const fxrow = (statusFX.get(String(token.dataset.id))||{});
        const stepBonus = (currentTurn === token.dataset.owner) ? (fxrow.moveBonus||0) : 0;
        let bearBonus = (fxrow && fxrow.bear && Number(fxrow.bear) > 0) ? 1 : 0;
        if (!bearBonus){
          const pill = document.querySelector(`.charCard[data-id="${token.dataset.id}"] .statusPill[data-k="bear"]`);
          if (pill) bearBonus = 1;
        }
        let steps = (hasMoved ? 1 : 2) + (moveBuff.stepsBonus || 0) + stepBonus + bearBonus;

        clearNonBlossomGhosts();
        const from = token.dataset.tile;
        const reach = reachable(from, steps, localWalls);
        for (const tid of reach){
          if (!occupied(tid, token) && !localWalls.has(tid)) addGhost(tid);
        }

        const startTile = token.dataset.tile;

        const onMove = (ev)=>{
          const pt = screenToBoard(ev.clientX, ev.clientY);
          token.style.left = `${pt.x}px`;
          token.style.top  = `${pt.y}px`;
        };

        const onUp = (ev)=>{
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          clearNonBlossomGhosts();

          const pt = screenToBoard(ev.clientX, ev.clientY);
          const logicalPt = toLogical(pt.x, pt.y);
          const snap = nearestTile(logicalPt.x, logicalPt.y);

          
          // Client-side guard: do not attempt to move onto a wall tile.
          if (localWalls && localWalls.has(snap.id)) {
            // snap back visually; server would reject anyway, but this avoids flicker
            const prev = startTile;
            const p = tilePositions[prev];
            const sxy = toScreen(p.x, p.y);
            token.style.left = `${sxy.x}px`;
            token.style.top  = `${sxy.y}px`;
            return;
          }
const hasMoved2 = token.dataset.hasMoved === "true";
          const fxrow2 = (statusFX.get(String(token.dataset.id))||{});
          const bearBonus2 = (fxrow2 && fxrow2.bear && Number(fxrow2.bear) > 0) ? 1 : 0;
          let steps2 = (hasMoved2 ? 1 : 2) + (moveBuff.stepsBonus || 0) + bearBonus2;
                    const d = shortestDistanceWithWalls(startTile, snap.id, localWalls);
          // Let the server validate the move; if invalid, it will snap back via 'invalidMove'.
pendingMoves.set(token.dataset.id, startTile);
          socket.emit('requestMove', { id: token.dataset.id, owner: token.dataset.owner, toTile: snap.id });
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    function refreshDraggables(){
      document.querySelectorAll('.token').forEach(t=>{
        if (!t.dataset.draggable &&
            t.dataset.owner === playerRole &&
            !GAME_ENDED && t.dataset.rooted !== "true") {
          makeDraggable(t);
          t.dataset.draggable = "1";
        }
      });
    }

    
    /* ---------- Root locks (Entangle) ---------- */
    function applyRootLocks(locks){document.querySelectorAll('.token').forEach(t=>{
        const id = t.dataset.id;
        const rooted = !!(locks && locks[id] && locks[id].entangle);
        if (rooted){
          t.classList.add('rooted');
          t.dataset.rooted = "true";
        }else {
          t.classList.remove('rooted');
          if (t.dataset.rooted) delete t.dataset.rooted;
        }
      });
      refreshDraggables();
    }
/* ---------- Character cards ---------- */
    function buildCharCard(id, owner, role, dead=false, displayName){
      initCharIfMissing(id, role, owner, displayName);
      const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : (ABIL_DEFS[role]||ABIL_DEFS.Tank));
      const st = charState.get(id);
      const pct = Math.max(0, Math.min(100, Math.round(100 * st.hp / st.maxHp)));
      const isAlly = owner === playerRole;

            let descPrimary;
if (
  (displayName === 'Don Atore') &&
  meta.primary && meta.primary.type === 'heal' &&
  (meta.primary.selfLossEqual === true)
) {
  // shorter copy per request
  descPrimary = `${meta.primary.name}: -1HP for +1HP (R${meta.primary.range})`;
} else {
        descPrimary = `${meta.primary.name}: ${meta.primary.type==='heal' ? (meta.primary.heal+' heal') : (meta.primary.dmg+' dmg')} (range ${meta.primary.range})`;
      }

      
      
      // --- Special description (short custom text for certain abilities) ---
      let descSpecial;
      const sName = (meta.special && meta.special.name ? String(meta.special.name).toLowerCase() : '');

      if (sName === 'transform') {
        descSpecial = 'Transform: become a bear';
      } else if (sName === 'voodoo doll') {
        // No range text for redirect
        descSpecial = 'Voodoo Doll: absorbs allies‚Äô damage';
      } else if (sName === 'swap') {
        // No range text for swap
        descSpecial = 'Swap: swap places';
      } else if (sName === 'fmj') {
        const r = (meta.special && meta.special.range != null) ? meta.special.range : 4;
        descSpecial = `FMJ: piercing shot (range ${r})`;
      } else if (meta.special.type === 'petal') {
        const healAmt = (meta.special.heal ?? 3);
        const r = (meta.special.radius ?? 1);
        descSpecial = `${meta.special.name || 'Healing Blossom'}: heal ${healAmt} (r${r} AoE)`;
      } else if (meta.special.type === 'swap' || meta.special.type === 'redirect') {
        // Fallback for other swap/redirect variants
        descSpecial = `${meta.special.name || 'Special'}: ability`;
      } else if (meta.special.type === 'selfHeal') {
        descSpecial = `${meta.special.name || 'Special'}: heal ${meta.special.heal} (self)`;
      } else if (meta.special.type === 'heal') {
        descSpecial = `${meta.special.name || 'Special'}: ${meta.special.heal} heal (range ${meta.special.range || 1})`;
      } else if (meta.special.type === 'damage') {
        descSpecial = `${meta.special.name || 'Special'}: ${meta.special.dmg} dmg (range ${meta.special.range || 1})`;
      } else {
        const r = (meta.special.range != null ? meta.special.range : null);
        descSpecial = `${meta.special.name || 'Special'}: ability${(r && r > 0) ? ` (range ${r})` : ''}`;
      }

      const wrap = document.createElement('div');

      wrap.className = 'charCard' + (dead ? ' dead' : '');
      wrap.dataset.id = id;
      wrap.dataset.role = role;

      const nameText = (displayName || id);

      wrap.innerHTML = `
        <div class="charName">${nameText} ${dead?'<span class="deadBadge">DEAD</span>':''}</div>
        <div class="charPortrait" style="background:${meta.color}22;border:1px solid #0003">${(()=>{const p=imagePathForName(nameText); return p? `<span class=\"emojiBackup\" style=\"display:none\">${meta.emoji}</span><img class=\"charImg\" src=\"${p}\" alt=\"${nameText}\"/>` : `${meta.emoji}`;})()}</div>
        <div class="charBody">
          <div class="statLine onlyHp">
            <span class="hpLine"><span class="hpIcon" aria-hidden="true">‚ù§Ô∏è</span> <b class="hp">${st.hp}</b>/<b class="hpmax">${st.maxHp}</b></span>
          </div>
          <div class="hpbar ${pct<=30?'danger':''}">
            <div class="fill" style="width:${pct}%"></div>
          </div>
          <div class="statusRow" aria-label="statuses"></div>
          <div class="desc">
            <div class="descLine">${descPrimary}</div>
            <div class="descLine">${descSpecial}</div>
          </div>
          <div class="btnRow">
            <button class="cbtn primaryBtn">Primary</button>
            <button class="cbtn specialBtn">Special</button>
          </div>
        </div>
`;
      // show cost if any
      (function(){
        const btn = wrap.querySelector('.specialBtn');
        if (btn && meta && meta.special && meta.special.energyCost){ btn.textContent = `Special (${meta.special.energyCost}‚ö°)`; }
      })();

      if (!isAlly || dead || GAME_ENDED || (playerRole !== currentTurn)){
        wrap.querySelectorAll('button').forEach(b=>b.disabled = true);
      }else{
        wrap.querySelector('.primaryBtn').onclick = (ev)=>{ ev.stopPropagation(); if (!turnState.usedAction) selectAbility('primary', id); };
        wrap.querySelector('.specialBtn').onclick = (ev)=>{
          ev.stopPropagation(); ev.preventDefault();
          if (turnState.usedAction) return;
          const role = getRoleState(id) || guessRoleFromId(id);
          const displayName = (charState.get(id)||{}).name;
          const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : ABIL_DEFS[role]);
          const def = meta && meta.special;
          if ((def && def.autoSelf === true) || (displayName === 'Loadstone' && kind === 'primary')) {
            try {
              socket.emit('useSpecial', { sourceId: id, targetId: id });
              if (def.type === 'redirect'){
                addOrUpdateStatusLocal(id, 'redirect', def.duration ?? 2);
              }
            } catch(e){ /* ignore */ }
            // clear any selection/ghosts
            abilitySel = null;
            document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
            clearGhosts();
            return;
          }
          // regular targeting flow
          selectAbility('special', id);
        };
      }
      return wrap;
    }

    function refreshPanelsFromChars(charsState){
      allyPanel.innerHTML = '';
      enemyPanel.innerHTML = '';

      for (const [id, cs] of Object.entries(charsState)){
        initCharIfMissing(id, cs.role, cs.owner, cs.name);
        const local = charState.get(id);
        local.owner = cs.owner;
        local.role = cs.role;
        local.maxHp = (typeof getMeta==='function' ? getMeta(cs.role, cs.name).maxHp : ABIL_DEFS[cs.role].maxHp);
        local.hp = Math.max(0, Math.min(local.maxHp, cs.hp ?? local.hp));
        local.cds = cs.cds ?? local.cds;
        local.dead = !!cs.dead;
        local.name = cs.name || id;

        const card = buildCharCard(id, cs.owner, cs.role, local.dead, local.name);
        if (cs.owner === playerRole) allyPanel.appendChild(card);
        else enemyPanel.appendChild(card);
      }
    }

    function guessRoleFromId(id){
      if (id.includes('P1') || id.includes('E1')) return 'Tank';
      if (id.includes('P2') || id.includes('E2')) return 'DPS1';
      if (id.includes('P3') || id.includes('E3')) return 'DPS2';
      return 'Support';
    }
    function syncTokenPortraits(){
      document.querySelectorAll('.token').forEach(tok=>{
        const id = tok.dataset.id;
        const el = document.querySelector(`.charCard[data-id="${id}"] .charPortrait`);
        if (el) tok.querySelector('.portrait').textContent = el.textContent.trim();
      });
    }
    function updateHPBar(id){
      const card = document.querySelector(`.charCard[data-id="${id}"]`);
      if (!card) return;
      const st = charState.get(id);
      const pct = Math.max(0, Math.min(100, Math.round(100*st.hp/st.maxHp)));
      const bar = card.querySelector('.hpbar');
      const fill = card.querySelector('.hpbar .fill');
      fill.style.width = pct + '%';
      bar.classList.toggle('danger', pct<=30);
      card.querySelector('.hp').textContent = st.hp;
      card.querySelector('.hpmax').textContent = st.maxHp;

      if (st.dead){
        card.classList.add('dead');
        const nameEl = card.querySelector('.charName');
        if (nameEl && !nameEl.querySelector('.deadBadge')){
          const b = document.createElement('span');
          b.className = 'deadBadge';
          b.textContent = 'DEAD';
          nameEl.appendChild(b);
        }
        card.querySelectorAll('button').forEach(b=>b.disabled = true);
      }
    }

    /* ---------- SIMPLE FLASH OVERLAY (1.25s, both screens) ---------- */
    function flashCard(id, kind){
      const card = document.querySelector(`.charCard[data-id="${id}"]`);
      if (!card) return;
      const overlay = document.createElement('div');
      overlay.className = 'hitOverlay ' + (kind === 'heal' ? 'heal' : 'dmg');
      card.appendChild(overlay);
      setTimeout(()=>{ if (overlay.parentNode) overlay.parentNode.removeChild(overlay); }, 1300);
    }

    /* ---------- Ability selection ---------- */
    let abilitySel = null;

    function selectAbility(kind, sourceId){
      if (GAME_ENDED) return;
      if (playerRole !== currentTurn) return;
      if (turnState.usedAction) return;

      const role = getRoleState(sourceId) || guessRoleFromId(sourceId);
      const displayName = (charState.get(sourceId)||{}).name;
      const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : ABIL_DEFS[role]);
      const def = (kind === 'primary') ? meta.primary : meta.special;
      const range = (def.range ?? 1) + (window.scopeBonusNext||0);
      
      /* Auto‚Äëself abilities (instant) */
      if (def && (def.autoSelf === true || (displayName === 'Loadstone' && kind === 'primary'))) {
        const evt = (kind === 'primary') ? 'usePrimary' : 'useSpecial';
        socket.emit(evt, { sourceId, targetId: sourceId });
        if (kind === 'special' && def.type === 'redirect'){
          addOrUpdateStatusLocal(sourceId, 'redirect', def.duration ?? 2);
        }
        abilitySel = null;
        document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
        clearGhosts();
        return;
      }


      const exact = (displayName === 'Aimbot' && kind === 'primary');

      
      // Toggle off if pressing the same ability again
      if (abilitySel && abilitySel.kind === kind && abilitySel.sourceId === sourceId){
        abilitySel = null;
        document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
        clearGhosts();
        return;
      }
abilitySel = { kind, sourceId, range, exact };

      document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
      const sc = document.querySelector(`.charCard[data-id="${sourceId}"]`);
      if (sc) sc.style.outline = '3px solid #ffd772';

      const token = document.querySelector(`.token[data-id="${sourceId}"]`);
      if (!token) return;
      const start = token.dataset.tile;
      let area = areaWithin(start, range, localWalls);
      if (exact && range>0){
        const inner = new Set(areaWithin(start, range-1, localWalls));
        area = area.filter(t=>!inner.has(t));
      }
      // Do NOT show red overlay for Healing Blossom
      const isPetalSpecial = (kind === 'special' && def && (def.type === 'petal' || (def.name||'').toLowerCase().includes('petal') || (def.name||'').toLowerCase().includes('blossom')));
      if (!isPetalSpecial) { highlightSet(area, 'attack'); } else { clearAttackGhosts(); }

    }

    function tileOfToken(id){
      const t = document.querySelector(`.token[data-id="${id}"]`);
      return t ? t.dataset.tile : null;
    }
    function distanceTiles(a, b){
      if (!a || !b) return Infinity;
      if (a === b) return 0;
      const seen = new Set([a]); const q = [[a,0]];
      while(q.length){
        const [cur, d] = q.shift();
        for (const n of neighbors(cur)){
          if (seen.has(n)) continue;
          if (n === b) return d+1;
          seen.add(n); q.push([n, d+1]);
        }
      }
      return Infinity;
    }

    /* [ENERGY] Card costs (match server) */
    function costOf(n){ try { return (CARD_COST[n] ?? CARD_COST[String(n).replace(/\s+/g,'')] ?? 0) | 0; } catch(e){ return 0; } }

const CARD_COST = {
Cleanse: 3,
  Siphon: 2,
  Fireball: 4,
  Entangle: 2,
  IronSkin: 3,
  Sprint: 2,
  Wall: 1,
  Shatter: 1,
  InvisibilityPotion: 2,
  Scope: 2,
  SideStep: 2,
  BearTrap: 2,
};

    /* ---------- Discard UI helpers ---------- */
    const CARD_DESC = {
Cleanse: 'Remove all status effects from a unit (any range)',
  Siphon:  'Instant: pay 2, gain 1 energy; opponent loses 3',
  Sprint:  'Gain 1 move',
  Wall:   'Place a wall (8 turns)',
  Shatter:'Remove a wall',
  Scope: '+1 range on next ability',
  'Side Step': 'Give a unit +1 move'
};

    function renderDiscard(slotEl, type){
  slotEl.innerHTML = '';
  const cardWrap = document.createElement('div');
  cardWrap.className = 'discardCard';
  if (!type){ slotEl.appendChild(cardWrap); return; }
  const img = document.createElement('img');
  img.className = 'discardImg';
  img.alt = type;
  img.src = cardImagePathFor(type);
  cardWrap.appendChild(img);
  slotEl.appendChild(cardWrap);
}


    function setDiscardByWho(who, type){
      if (!type) return; // persist last shown discard if server sends null/undefined


// If Dungeon Master used 1D6 while Skill Check is active, 
// swap to the '1D6SC-(roll+1)' artwork.
(function(){
  try {
    const m = /^1D6-(\d)$/.exec(type);
    if (m) {
      const rolled = parseInt(m[1], 10);
      // detect if this 'who' currently controls a Dungeon Master with Skill Check
      let hasSC = false;
      let dmId = null;
      for (const [id, st] of (window.charState || new Map()).entries()) {
        if (st && st.owner === who && String(st.name).toLowerCase() === 'dungeon master') {
          dmId = String(id);
          break;
        }
      }
      if (dmId) {
        const fx = (window.statusFX && window.statusFX.get(dmId)) || {};
        hasSC = !!fx.skillCheck;
      }
      if (hasSC) {
        const boosted = Math.min(7, rolled + 1);
        type = `1D6SC-${boosted}`;
      }
    }
  } catch(e) { /* no-op */ }
})();

      
    // Play Nectar of Life voice line when its image lands in *your* discard slot
    try{
      // Normalize the type and gate so we only react when the discard actually CHANGES.
      window.__discardSeen = window.__discardSeen || { player1:null, player2:null };
      const _norm = String(type || '').toLowerCase().replace(/[\s_]+/g,'');
      const _changed = (window.__discardSeen[who] !== _norm);
      window.__discardSeen[who] = _norm;
      const _isNectar = (_norm === 'nectaroflife' || _norm === 'mend');
      if (_changed && _isNectar && typeof playVoice === 'function' && who === playerRole){
        playVoice('NectarOfLife');
      }
    }catch(_){}
    // --- Ensure Healing Blossom spawns as a *new* card every time ---
    // We append a zero-width char to the type so the UI treats sequential plays as distinct,
    // but cardImagePathFor() strips it so the image path stays '/Healing_Blossom.png'.
    (function(){
      try {
        let _n = String(type || '').toLowerCase().replace(/[\s_]+/g,'');
        const isHB = (_n === 'healingblossom' || _n === 'healingbloom' || _n === 'blossomwall');
        if (isHB){
          window.__hbNonce = (window.__hbNonce || 0) + 1;
          const ZWS = ['\u200B','\u200C','\u200D','\uFEFF'];
          type = String(type) + ZWS[window.__hbNonce % ZWS.length];
        }
      } catch(_) {}
    })();

    if (playerRole === 'player1'){
        if (who === 'player1') renderDiscard(discardSelfSlot, type);
        else if (who === 'player2') renderDiscard(discardOtherSlot, type);
      }else if (playerRole === 'player2'){
        if (who === 'player2') renderDiscard(discardSelfSlot, type);
        else if (who === 'player1') renderDiscard(discardOtherSlot, type);
      }else{
        if (who === 'player1') renderDiscard(discardOtherSlot, type);
        if (who === 'player2') renderDiscard(discardSelfSlot, type);
      }
    }

    /* ---------- Board clicks ---------- */
    board.addEventListener('click', (e)=>{
    // Cancel Blossom special if clicking UI inside the board (buttons, cards, etc.)
    if (window.abilitySel && window.abilitySel.kind === 'special'){
      const uiHit = e.target.closest('#end-turn, .charCard, #hand, .cbtn, .primaryBtn, .specialBtn, .card, button');
      if (uiHit && !e.target.closest('.token')){
        window.abilitySel = null;
        document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
        if (typeof clearGhosts === 'function') clearGhosts();
        return; // do not place
      }
    }
      if (GAME_ENDED) return;
      if (e.target.closest('.card') || e.target.closest('.panel') || e.target.closest('#end-turn')) return;

      const targetTok = e.target.closest('.token');

      // Ability targeting
      if (abilitySel && targetTok){
        const { sourceId, range, kind } = abilitySel;
        const targetId = targetTok.dataset.id;
        const d = distanceTiles(tileOfToken(sourceId), tileOfToken(targetId));
        if (d !== Infinity && d <= range){
          // Don Atore continuous tap-heal: intercept and keep selection armed
          try{
            const srcState = (charState && charState.get) ? charState.get(sourceId) : null;
            const srcName = srcState && srcState.name;
            const role = getRoleState(sourceId);
            const meta = getMeta(role, srcName);
            if (srcName === 'Don Atore' && meta && meta.primary && meta.primary.type === 'tapHeal' && targetTok.dataset.owner === playerRole){
              if (typeof socket !== 'undefined'){ socket.emit('don:tapHeal', { sourceId, targetId }); }
              try{ targetTok.classList.add('healPulse'); setTimeout(()=>targetTok.classList.remove('healPulse'), 180);}catch(_){}
              return; // stay armed
            }
          }catch(_){}
          if (kind === 'primary'){ socket.emit('usePrimary', { sourceId, targetId }); }
          else { socket.emit('useSpecial', { sourceId, targetId }); }
        }
        abilitySel = null;
        document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
        clearGhosts();
        return;
      }

      // Armed card interactions (Wall/Shatter/Teleport)
      if (!cardArmed) return;
      const name = (selectedCard && selectedCard.dataset.card) || armedCardName;
      if (!name) return;

      const __pt = screenToBoard(e.clientX, e.clientY);
      const logicalPt = toLogical(__pt.x, __pt.y);
      const snap = nearestTile(logicalPt.x, logicalPt.y);

      if (name === 'Wall'){
        if (myEnergy() < (CARD_COST['Wall']||0)) { flashEnergyNotEnough(); return; }
          socket.emit('playCard', { type:'Wall', tile:snap.id });
        applyWallLocal(snap.id);
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        cardArmed = false;
        return;
      }
      if (name === 'Bear Trap'){
        if (myEnergy() < (CARD_COST['BearTrap']||0)) { flashEnergyNotEnough(); return; }
        const occ = occupied(snap.id) || localWalls.has(snap.id) || (localTraps && localTraps.has && localTraps.has(snap.id));
        if (occ) return;
        // Server placement (authoritative) + local UI
        socket.emit('playCard', { type:'BearTrap', tile:snap.id });
        applyTrapLocal(snap.id);
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        cardArmed = false;
        return;
      }
      if (name === 'Shatter'){
        if (myEnergy() < (CARD_COST['Shatter']||0)) { flashEnergyNotEnough(); return; }
        if (!localWalls.has(snap.id)) return;
        socket.emit('playCard', { type:'Shatter', tile:snap.id });
        removeWallLocal(snap.id);
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        cardArmed = false;
        return;
      }
      if (name === 'Teleport' && teleportSel.active && teleportSel.source){
        if (myEnergy() < (CARD_COST['Teleport']||0)) { flashEnergyNotEnough(); return; }
        if (turnState.usedMovement) return;
        socket.emit('playCard', { type:'Teleport', sourceId:teleportSel.source, toTile:snap.id });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        resetTeleport();
        cardArmed = false;
        return;
      }
    });

    /* ---------- Cards (hand) ---------- */
    const deck = [
  { n:'Cleanse', d:'Remove all status effects from a unit' },
  { n:'Siphon',  d:'Instant energy swing (you +1, opponent -3)' },
  { n:'Fireball', d:'Burn: 2 damage per turn for 3 turns' },
  { n:'Entangle', d:'Root the enemy for 2 turns' },
  { n:'Iron Skin', d:'Reduce damage taken by 2 for 2 turns' },
  { n:'Invisibility Potion', d:'Become invisible for 2 turns' },
  { n:'Sprint', d:'Gain 1 move' },
  { n:'Wall',     d:'Place a wall (8 turns)' },
  { n:'Shatter',  d:'Remove a wall' },
  { n:'Scope', d:'Add +1 range on next ability' },
  { n:'Side Step', d:'Give a unit +1 move' },
  { n:'Bear Trap', d:'Trap that damages and immobilizes opponents' },
];
    let deckIdx = 0;

    function positionPlayFloat(cardEl){
      const r = cardEl.getBoundingClientRect();
      const boardR = board.getBoundingClientRect();
      const x = r.left + r.width/2 - boardR.left;
      const y = r.top - boardR.top - 6; // above the card
      playFloat.style.left = x + 'px';
      playFloat.style.top  = y + 'px';
    }
    function showPlayFloat(cardEl){
  positionPlayFloat(cardEl);
  const nm = cardEl?.dataset?.card;
  const need = costOf(nm);
  const have = myEnergy();
  if (need > 0 && have < need) playFloat.classList.add('disabled'); else playFloat.classList.remove('disabled');
  playFloat.style.display = 'inline-block';
}
    function hidePlayFloat(){ playFloat.style.display = 'none'; }

    function playSelected(){
      if (!selectedCard || GAME_ENDED) return;
      const name = selectedCard.dataset.card;
      if (turnState.cardPlayed) return;
      if ((name === 'Wall' || name === 'Shatter' || name === 'Scout') && turnState.usedAction) return;

      

      
      // Energy gate: if you can't afford the card, don't arm or discard
      const _need = costOf(name);
      if (_need > 0 && myEnergy() < _need){ flashEnergyNotEnough(); return; }
// Target-only cards: click Play then click a unit to apply the effect
      if (name === 'Fireball' || name === 'Entangle' || name === 'Iron Skin' || name === 'Cleanse' || name === 'Invisibility Potion'){
        simpleTarget = { card: name };
        cardArmed = true;
        label1.textContent = 'Click a unit to apply ' + name;
        label1.style.display = 'block';
        // NEW: reveal + discard now so the card no longer blocks the bottom row
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        socket.emit('revealCard', { type: name });
        return;
      }
      // Siphon ‚Äî instant cast (no target)
      if (name === 'Scope'){
        if (myEnergy() < (CARD_COST['Scope']||0)) { flashEnergyNotEnough(); return; }
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        socket.emit('revealCard', { type: name });
        socket.emit('playCard', { type:'Scope' });
        return;
      }

      if (name === 'Siphon'){
        if (myEnergy() < (CARD_COST['Siphon']||0)) { flashEnergyNotEnough(); return; }
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        socket.emit('revealCard', { type: name });
        socket.emit('playCard', { type:'Siphon' });
        return;
      }

      // Bear Trap ‚Äî arm and choose a tile
      if (name === 'Bear Trap'){
        if (myEnergy() < (CARD_COST['BearTrap']||0)) { flashEnergyNotEnough(); return; }
        const open = Object.keys(tilePositions).filter(t=> !occupied(t) && !localWalls.has(t) && !(localTraps && localTraps.has && localTraps.has(t)));
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        armedCardName = 'Bear Trap';
        socket.emit('revealCard', { type: name });
        highlightSet(open, 'attack');
        cardArmed = true;
        return;
      }


    // Movement buffs (immediate resolve)
      if (name === 'Side Step'){
        // Mirror Sprint structure: energy check, movement gate, emit + discard
        if (myEnergy() < (CARD_COST['SideStep']||0)) { flashEnergyNotEnough(); return; }
        socket.emit('playCard', { type:'SideStep' });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        return;
      }

      if (name === 'Sprint'){
        if (myEnergy() < (CARD_COST['Sprint']||0)) { flashEnergyNotEnough(); return; }
        if (turnState.usedMovement) return;
        moveBuff.stepsBonus = (moveBuff.stepsBonus||0) + 1;
        socket.emit('playCard', { type:'Sprint' });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        return;
      }
      if (name === 'Dash'){
        if (myEnergy() < (CARD_COST['Dash']||0)) { flashEnergyNotEnough(); return; }
        if (turnState.usedMovement) return;
        moveBuff.stepsBonus = (moveBuff.stepsBonus||0) + 2;
        socket.emit('playCard', { type:'Dash' });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        return;
      }
      if (name === 'Blink'){
        if (myEnergy() < (CARD_COST['Blink']||0)) { flashEnergyNotEnough(); return; }
        if (turnState.usedMovement) return;
        moveBuff.minSteps = Math.max(moveBuff.minSteps||0, 2);
        socket.emit('playCard', { type:'Blink' });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        return;
      }
      if (name === 'Scout'){
        socket.emit('playCard', { type:'Scout' });
        clearGhosts();
        document.querySelectorAll('.token').forEach(t=>{
          if (t.dataset.owner === playerRole) return;
          const from = t.dataset.tile;
          const hasMoved = t.dataset.hasMoved === "true";
          const r = reachable(from, hasMoved ? 1 : 2, localWalls);
          for (const tid of r) addGhost(tid, 'enemy');
        });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        return;
      }

      // Cards requiring target on board
      if (name === 'Wall'){
        if (myEnergy() < (CARD_COST['Wall']||0)) { flashEnergyNotEnough(); return; }
        const open = Object.keys(tilePositions).filter(t=>!occupied(t) && !localWalls.has(t));
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        armedCardName = 'Wall';
        socket.emit('revealCard', { type:'Wall' });
        highlightSet(open, 'attack'); cardArmed = true; return;
      }
      if (name === 'Shatter'){
        if (myEnergy() < (CARD_COST['Shatter']||0)) { flashEnergyNotEnough(); return; }
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        armedCardName = 'Shatter';
        socket.emit('revealCard', { type:'Shatter' });
        highlightSet([...localWalls], 'block'); cardArmed = true; return;
      }
      if (name === 'Teleport'){
        if (turnState.usedMovement) return;
        clearGhosts();
        document.querySelectorAll('.token').forEach(t=>{
          if (t.dataset.owner === playerRole) addGhost(t.dataset.tile, 'attack');
        });
        moveToDiscard(selectedCard);
        playedCardThisTurn = true;
        armedCardName = 'Teleport';
        teleportSel = { active:false, source:null };
        cardArmed = true; return;
      }
    }

    const CARD_IMG = {'Iron Skin': 'Iron_Skin.png',
  'Invisibility Potion': 'Invisibility_Potion.png',
  'Side Step': 'Side_Step.png',
  'SideStep': 'Side_Step.png',
  'Scope': 'Scope.png',
  'Bear Trap': 'Bear_Trap.png',
  'BearTrap': 'Bear_Trap.png'
};

// Map for character-ability images in /assets/Character Ability Cards
const ABILITY_CARD_IMG = {
  
  
  "Replenish":"Replenish.png","Blood Donation":"Blood_Donation.png","Transform":"Transform.png",
  "Bear Claw":"Bear_Claw.png",
  "Paw Swipe":"Paw_Swipe.png",
  "1D6":"1D6.png",
  "Skill Check":"Skill_Check.png",
  // Canonical Death Blossom images
  'Healing Blossom':'Healing_Blossom.png',
  'Nectar of Life':'Nectar_Of_Life.png',
  // Legacy aliases routed to the new art (display only)
  'Healing Bloom':'Healing_Blossom.png',
  'Mend':'Nectar_Of_Life.png',
  'BlossomWall':'Healing_Blossom.png'
,
  "Sleight of Hand":"Sleight_Of_Hand.png",
  "Swap":"Swap.png",
  "Pin Cushion":"Pin_Cushion.png",
  "Voodoo Doll":"Voodoo_Doll.png",
  "True Shot":"True_Shot.png",
  "FMJ":"FMJ.png",
  "Reverse Polarity":"Reverse_Polarity.png",
  "Polar Attraction":"Polar_Attraction.png"
,
  "Saving Throw":"Saving_Throw.png"
};

function cardImagePathFor(type){
  // Normalize: strip zero-width markers used to force unique discards
  type = String(type).replace(/[\u200B-\u200D\uFEFF]/g, '');
  // DM dice w/ Skill Check -> 1d6SC-2..7.png
  if (/^1D6SC-[2-7]$/i.test(type)) {
    const face = String(type).split('-')[1];
    return `/assets/Character Ability Cards/1d6SC-${face}.png`;
  }
  // Normal DM dice -> 1d6-1..6.png
  if (/^1D6-[1-6]$/i.test(type)) {
    const face = String(type).split('-')[1];
    return `/assets/Character Ability Cards/1d6-${face}.png`;
  }
  // Direct map (includes Saving Throw)
  if (ABILITY_CARD_IMG[type]) {
    return `/assets/Character Ability Cards/${ABILITY_CARD_IMG[type]}`;
  }
  const file = CARD_IMG[type] || (String(type).replace(/\s+/g, '_') + '.png');
  return `/assets/Cards/${file}`;
}


function createCardEl(name, desc=''){
  const c = document.createElement('div');
  c.className = 'card imgcard';
  c.dataset.card = name;
  const fileName = (CARD_IMG[name] || (name.replace(/\s+/g, '_') + '.png'));
  const img = document.createElement('img');
  img.className = 'cardImg';
  img.alt = name;
  img.src = `/assets/Cards/${fileName}`;
  c.appendChild(img);
  c.onclick = (ev)=>{
    ev.stopPropagation();
    if (GAME_ENDED) return;
    if (playerRole !== currentTurn) return;
    if (turnState.cardPlayed && (!selectedCard || selectedCard !== c)) return;
    if (selectedCard === c){
      c.classList.remove('selected'); selectedCard=null; clearGhosts(); resetTeleport(); cardArmed=false;
      document.body.classList.remove('has-selected');
      hidePlayFloat();
      return;
    }
    if (selectedCard){ selectedCard.classList.remove('selected'); }
    c.classList.add('selected'); selectedCard = c; cardArmed=false;
    document.body.classList.add('has-selected');
    showPlayFloat(c);
  };
  return c;
}
playFloat.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      if (!selectedCard) return;
      playSelected();
    });

    function fillStartHand(){
      hand.innerHTML = '';
      for (let i=0;i<5;i++){
        const spec = deck[deckIdx % deck.length]; deckIdx++;
        hand.appendChild(createCardEl(spec.n, spec.d));
      }
      placeEndButton();
    }
    const MAX_HAND = 5;
function handNonPlaceholderCount(){ return hand.querySelectorAll('.card:not(.placeholder)').length; }
function handTotalSlots(){ return hand.querySelectorAll('.card').length; }
function ensureHandSlots(){
  let slots = handTotalSlots();
  while (slots < MAX_HAND){ const ph = document.createElement('div'); ph.className='card placeholder'; hand.appendChild(ph); slots++; }
}
function insertIntoFirstPlaceholder(el){
  ensureHandSlots();
  if (handNonPlaceholderCount() >= MAX_HAND){ return; }
  const ph = hand.querySelector('.card.placeholder');
  if (ph) hand.replaceChild(el, ph);
  else if (handNonPlaceholderCount() < MAX_HAND) hand.appendChild(el);
  placeEndButton();
}

    function drawOneAtEnd(){
  if (handNonPlaceholderCount() >= MAX_HAND) return;
  const spec = deck[deckIdx % deck.length]; deckIdx++;
  insertIntoFirstPlaceholder(createCardEl(spec.n, spec.d));
}

    function moveToDiscard(cardEl){
      if (!cardEl) return;
      cardEl.classList.remove('selected');
      const ph = document.createElement('div');
      ph.className = 'card placeholder';
      hand.replaceChild(ph, cardEl);
      selectedCard = null;
      document.body.classList.remove('has-selected');
      hidePlayFloat();
      clearGhosts();
      // draw replacement immediately
      if (typeof drawOneAtEnd === 'function') { drawOneAtEnd(); }
      placeEndButton();
      }

    function previewEnemyReach(){
      clearGhosts();
      document.querySelectorAll('.token').forEach(t=>{
        if (t.dataset.owner === playerRole) return;
        const from = t.dataset.tile;
        const hasMoved = t.dataset.hasMoved === "true";
        const r = reachable(from, hasMoved ? 1 : 2, localWalls);
        for (const tid of r) addGhost(tid, 'enemy');
      });
    }

    let teleportSel = { active:false, source:null };
    function resetTeleport(){ teleportSel = { active:false, source:null }; }

    board.addEventListener('mousedown', (e)=>{
      if (!selectedCard || selectedCard.dataset.card !== 'Teleport' || !cardArmed) return;
      if (myEnergy() < (CARD_COST['Teleport']||0)) { flashEnergyNotEnough(); return; }
      const tok = e.target.closest('.token');
      if (!tok) return;
      if (tok.dataset.owner !== playerRole) return;
      teleportSel = { active:true, source: tok.dataset.id };
      const start = tok.dataset.tile;
      highlightSet(reachable(start, 3, null), 'attack');
      e.stopPropagation(); e.preventDefault();
    }, true);

    // End turn
    endBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); 
    // Keyboard shortcuts: Space = End Turn, Esc = Home
    document.addEventListener('keydown', (e) => {
      const activeTag = (document.activeElement && document.activeElement.tagName) || '';
      const typing = activeTag === 'INPUT' || activeTag === 'TEXTAREA' || activeTag === 'SELECT' || document.activeElement?.isContentEditable;
      if (typing) return;
      // Space -> End Turn (same checks as button)
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        if (!GAME_ENDED && playerRole === currentTurn) {
          endBtn.click();
        }
      }
      // Escape -> Back to Home
      if (e.code === 'Escape' || e.key === 'Escape') {
        e.preventDefault();
        location.href = '/home';
      }
    }, { passive: false });
if (GAME_ENDED) return; if (playerRole !== currentTurn) return; try { abilitySel = null; document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active')); document.querySelectorAll('.charCard').forEach(c=>c.style.outline=''); if (typeof clearGhosts==='function') clearGhosts(); } catch(_){} socket.emit('endTurn'); });

    // Simple target flow: Fireball / Entangle / Iron Skin (Play ‚Üí click unit)
    board.addEventListener('mousedown', (e)=>{
      if (!cardArmed || !simpleTarget) return;
      const tok = e.target.closest('.token'); if (!tok) return;
      const name = simpleTarget.card;
      if (name === 'Fireball'){
        if (myEnergy() < (CARD_COST['Fireball']||0)) { flashEnergyNotEnough(); return; }
        if (tok.dataset.owner === playerRole) return; // enemy only
        socket.emit('playCard', { type: 'Fireball', targetId: tok.dataset.id });
      } else if (name === 'Entangle'){
        if (myEnergy() < (CARD_COST['Entangle']||0)) { flashEnergyNotEnough(); return; }
        if (tok.dataset.owner === playerRole) return; // enemy only
        socket.emit('playCard', { type: 'Entangle', targetId: tok.dataset.id });
      } else if (name === 'Iron Skin'){
        if (myEnergy() < (CARD_COST['IronSkin']||0)) { flashEnergyNotEnough(); return; }
        if (tok.dataset.owner !== playerRole) return; // ally only
        socket.emit('playCard', { type: 'IronSkin', targetId: tok.dataset.id });
      } else if (name === 'Cleanse'){
        if (myEnergy() < (CARD_COST['Cleanse']||0)) { flashEnergyNotEnough(); return; }
        socket.emit('playCard', { type: 'Cleanse', targetId: tok.dataset.id });
      } else if (name === 'Invisibility Potion'){
        if (myEnergy() < (CARD_COST['InvisibilityPotion']||CARD_COST['Invisibility Potion']||0)) { flashEnergyNotEnough(); return; }
        if (tok.dataset.owner !== playerRole) return; // ally only
        socket.emit('playCard', { type: 'InvisibilityPotion', targetId: tok.dataset.id });
      } else {
        return;
      }
      // already discarded on Play; just finalize
      simpleTarget = null; cardArmed = false;
      label1.style.display = 'none';
    });
    

    /* ---------- Name tags ---------- */
    function updateNameTags(full){
      if (!full || !full.playerNames) return;
      const p1 = full.playerNames.player1 || 'Player 1';
      const p2 = full.playerNames.player2 || 'Player 2';
      if (playerRole === 'player2') {
        label1.textContent = p2; // left shows "you" when you're P2
        label2.textContent = p1;
      } else {
        label1.textContent = p1;
        label2.textContent = p2;
      }
      label1.style.display = 'block';
      label2.style.display = 'block';
    }

    /* ---------- HP cache so flashes work on resyncs & events ---------- */
    const lastHp = new Map(); // id -> last known hp

    function recordHpFromServerChars(serverChars){
      for (const [id, cs] of Object.entries(serverChars)){
        const meta = getMeta(cs.role, cs.name);
        const hp = Math.max(0, Math.min(meta.maxHp, cs.hp ?? meta.maxHp));
        lastHp.set(id, hp);
      }
    }

    /* ---------- Sockets ---------- */
    socket.on('assignRole', role=>{
      playerRole = role;
      
      // mark POV for CSS (ally green / enemy red)
      try{
        document.body.classList.remove('asP1','asP2');
        if (role === 'player1' || role === 'player2'){
          document.body.classList.add(role === 'player1' ? 'asP1' : 'asP2');
        }
      }catch(_){}
fillStartHand();
      placeEndButton();
      setBanner();
      applyInvisibilityOverlays();
      refreshDraggables();
      if (window.__lastFullState) updateNameTags(window.__lastFullState);
    });

    
    function renderControlFromState(full){
      try{
        const box = document.getElementById('controlScoreBox');
        const p1 = document.getElementById('p1Score');
        const p2 = document.getElementById('p2Score');
        const sp1 = document.getElementById('seriesP1');
        const sp2 = document.getElementById('seriesP2');
        let overlay = document.getElementById('controlOverlayLayer');
        let flag = document.getElementById('controlFlag');
        if (!full || full.mode !== 'control' || !full.control){
          if (box) box.style.display = 'none';
          if (flag) flag.style.display = 'none';
          if (window.__controlOverlays){ window.__controlOverlays.forEach(el=>el.remove()); }
          window.__controlOverlays = [];
          return;
        }
        if (box) box.style.display = 'block';
        if (playerRole === 'player2') {
          if (p1) p1.textContent = String((full.control.progress?.player2 ?? full.control.tally?.player2 ?? 0));
          if (p2) p2.textContent = String((full.control.progress?.player1 ?? full.control.tally?.player1 ?? 0));
          if (sp1) sp1.textContent = String(full.control.scores?.player2 ?? 0);
          if (sp2) sp2.textContent = String(full.control.scores?.player1 ?? 0);
        } else {
          if (p1) p1.textContent = String((full.control.progress?.player1 ?? full.control.tally?.player1 ?? 0));
          if (p2) p2.textContent = String((full.control.progress?.player2 ?? full.control.tally?.player2 ?? 0));
          if (sp1) sp1.textContent = String(full.control.scores?.player1 ?? 0);
          if (sp2) sp2.textContent = String(full.control.scores?.player2 ?? 0);
        }
        if (window.__controlOverlays){ window.__controlOverlays.forEach(el=>el.remove()); }
        window.__controlOverlays = [];
        const tiles = full.control.tiles || [];
        tiles.forEach(id=>{
          const p = tilePositions[id]; if (!p) return;
          const s = toScreen(p.x,p.y);
          const el = document.createElement('div'); el.className='ghost control'; el.style.left=s.x+'px'; el.style.top=s.y+'px'; el.title=id;
          overlay.appendChild(el); window.__controlOverlays.push(el);
        });
        const anc = full.control.anchor;
        const pos = tilePositions[anc];
        if (pos){
          const s = toScreen(pos.x,pos.y);
          flag.style.left = s.x+'px'; flag.style.top = s.y+'px'; flag.style.display='block';
        }
      }catch(e){/*noop*/}
    }
socket.on('fullState', full=>{ renderControlFromState(full);
      try{ if (full && full.backgroundUrl){ document.documentElement.style.setProperty('background', `#111 url('${full.backgroundUrl}') center / cover no-repeat fixed`, 'important'); } }catch(_){/*noop*/}
      window.__lastFullState = full;
      updateNameTags(full);
      positionEnergyBox(true);
      // Lock UI anchors so they don't drift after interactions
      try{ window.__uiLockHard = true; }catch(e){}

      const tokensState = full.tokens || {};
      const serverChars = full.chars || {};

      // Build list of flashes by comparing against lastHp (for both clients)
      const toFlash = [];
      for (const [id, cs] of Object.entries(serverChars)){
        const meta = getMeta(cs.role, cs.name);
        const nextHp = Math.max(0, Math.min(meta.maxHp, cs.hp ?? meta.maxHp));
        const prevHp = lastHp.has(id) ? lastHp.get(id) : null;
        if (prevHp !== null && prevHp !== nextHp){
          toFlash.push({ id, kind: nextHp < prevHp ? 'dmg' : 'heal' });
        }
      }

      // Update local character state
      for (const [id, cs] of Object.entries(serverChars)){
        initCharIfMissing(id, cs.role, cs.owner, cs.name);
        const meta = getMeta(cs.role, cs.name);
        charState.set(id, {
          role: cs.role,
          owner: cs.owner,
          hp: Math.max(0, Math.min(meta.maxHp, cs.hp ?? meta.maxHp)),
          maxHp: meta.maxHp,
          cds: cs.cds ?? {special:0},
          dead: !!cs.dead,
          name: cs.name || id
        });
      }

      // Update walls and tokens
      localWalls.clear(); clearGhosts();
      reconcileWallOverlays(full.blocked||[]);
      localTraps.clear();
      reconcileTrapOverlays((full.traps||[]).filter(t=>t && t.owner===playerRole));
      (full.traps||[]).forEach(t=>{ if (t && t.owner === playerRole) applyTrapLocal(t.tile); });

      (full.blocked||[]).forEach(w=> applyWallLocal(w.tile));
      (full.blossomBlocked||[]).forEach(w=> { (w.owner===playerRole ? applyBlossomWallLocal : applyEnemyBlossomWallLocal)(w.tile); });
      (full.blossomPinkBlocked||[]).forEach(w=> { (w.owner===playerRole ? applyBlossomPinkWallLocal : applyEnemyBlossomPinkWallLocal)(w.tile); });
      spawnAllFromState(tokensState);

      // [ENERGY] bar update
      if (full.energy){ energyBySeat = full.energy; updateEnergyBar(full.energy[playerRole]||0, full.energyMax||10); }
      // Rebuild panels and sync portraits
      refreshPanelsFromChars(serverChars);
      syncTokenPortraits();
      // Re-apply active state for armed primary after panel rebuild
      try {
        if (window.abilitySel && abilitySel.kind === 'primary') {
          const btn = document.querySelector(`.charCard[data-id="${abilitySel.sourceId}"] .primaryBtn`);
          if (btn) btn.classList.add('active');
        }
      } catch(_){}
    
      applyRootLocks(full.locks || {});
      applyStatusFX(full.fx || {});
      try{ applyInvisibilityOverlays(); }catch(_){}

      // Play flashes after DOM exists
      if (toFlash.length){
        setTimeout(()=> toFlash.forEach(f=> flashCard(f.id, f.kind)), 0);
      }

      // Record new hp snapshot
      recordHpFromServerChars(serverChars);

      // Discards
      if (full.lastDiscard){
        setDiscardByWho('player1', full.lastDiscard.player1 || null);
        setDiscardByWho('player2', full.lastDiscard.player2 || null);
      }

      // Turn + UI
      currentTurn = full.currentTurn || currentTurn;
      if (full.turn){
        turnState = Object.assign({ usedMovement:false, usedAction:false, cardPlayed:false }, full.turn);
      }
      setBanner();
      applyInvisibilityOverlays();
      placeEndButton();

      // re-place play float if selection exists
      if (selectedCard) showPlayFloat(selectedCard);
      refreshDraggables();
    });

    socket.on('nextTurn', who=>{__turnTick++; try{ for (const [tid,placed] of Array.from(trapPlacedAtTick.entries())){ if ((__turnTick - (placed|0)) >= 4){ hideTrapOverlay(tid); trapSuppressedLocal && trapSuppressedLocal.add && trapSuppressedLocal.add(tid); trapPlacedAtTick.delete(tid); if (trapTTL) trapTTL.delete(tid); } } }catch(_){ }  try{ for (const [tid,n] of Array.from(trapTTL.entries())){ const left=(n|0)-1; if (left<=0){ hideTrapOverlay(tid); trapTTL.delete(tid); try{ trapTilesAnyOwner && trapTilesAnyOwner.delete && trapTilesAnyOwner.delete(tid); }catch(_){ } try{ trapSuppressedLocal && trapSuppressedLocal.add && trapSuppressedLocal.add(tid); }catch(_){ } } else { trapTTL.set(tid,left); } } for (const [tid,n] of Array.from(trapCaughtTTL.entries())){ const left=(n|0)-1; if (left<=0){ hideTrapCaughtOverlay(tid); trapCaughtTTL.delete(tid); } else { trapCaughtTTL.set(tid,left); } } }catch(_){ } 
      // Ensure client UI permits fresh move/action each turn
      turnState = { usedMovement:false, usedAction:false, cardPlayed:false };
      const wasMine = (playerRole !== who);
      currentTurn = who; setBanner();
      applyInvisibilityOverlays();

      if (wasMine){ playedCardThisTurn = false; }

      moveBuff = { stepsBonus:0, minSteps:0 };
      clearGhosts(); resetTeleport();
      if (selectedCard){ selectedCard.classList.remove('selected'); }
      selectedCard=null; cardArmed=false;
      document.body.classList.remove('has-selected');
      hidePlayFloat();
      document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
      pendingMoves.clear();
      placeEndButton();
    
      // Disable own ability buttons when it's NOT our turn; enable on our turn
      try {
        const ally = document.getElementById('allyPanel');
        if (ally){
          const shouldDisable = (playerRole !== currentTurn) || GAME_ENDED;
          ally.querySelectorAll('.cbtn').forEach(b=> b.disabled = shouldDisable);
          // Also clear any armed primary visual if turn switched away
          if (shouldDisable){
            window.abilitySel = null;
            ally.querySelectorAll('.primaryBtn').forEach(b=> b.classList.remove('active'));
            document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
            clearGhosts();
          }
        }
        const enemy = document.getElementById('enemyPanel');
        if (enemy){ enemy.querySelectorAll('.cbtn').forEach(b=> b.disabled = true); }
      } catch(_){}
});

    socket.on('move', ({ id, owner, toTile, capturedId })=>{
      try{ lastMoveToTile.set(String(id), toTile); lastMoveAt.set(String(id), Date.now()); }catch(_){ } try{ if (toTile && localTraps && localTraps.has && localTraps.has(toTile)) { hideTrapOverlay(toTile); try{ localTraps.delete(toTile); }catch(_){ } showTrapCaughtOverlay(toTile); } }catch(_){ } if (owner === playerRole && moveBuffOnce) { moveBuff.stepsBonus = 0; moveBuffOnce = false; } const token = document.querySelector(`.token[data-id="${id}"]`);
      if (token){
        token.dataset.tile = toTile;
        token.dataset.hasMoved = "true";
        const p = tilePositions[toTile];
        const s = toScreen(p.x, p.y);
        token.style.left = `${s.x}px`;
        token.style.top  = `${s.y}px`;
      }
      if (capturedId){
        const dead = document.querySelector(`.token[data-id="${capturedId}"]`);
        if (dead) dead.remove();
        if (charState.has(capturedId)){
          const st = charState.get(capturedId); st.hp = 0; st.dead = true; updateHPBar(capturedId);
          flashCard(capturedId, 'dmg');
          lastHp.set(capturedId, 0);
        }
      }
      pendingMoves.delete(id);
    });

    socket.on('invalidMove', ({ id })=>{
      const token = document.querySelector(`.token[data-id="${id}"]`);
      const prev = pendingMoves.get(id) || token?.dataset.tile;
      if (token && prev){
        const p = tilePositions[prev];
        const s = toScreen(p.x, p.y);
        token.style.left = `${s.x}px`;
        token.style.top  = `${s.y}px`;
      }
      pendingMoves.delete(id);
    });

    socket.on('hpUpdate', ({ id, hp, prev, type }) => {
      // Determine "before" HP reliably:
      // Prefer the server-provided prev; otherwise use local charState or lastHp.
      const beforeLocal =
        (prev != null) ? prev :
        (charState.get(id)?.hp ?? (lastHp.has(id) ? lastHp.get(id) : null));

      if (!charState.has(id)) initCharIfMissing(id);

      setHP(id, hp);
      updateHPBar(id);

      // Decide flash kind using server 'type' when available (most reliable)
      if (beforeLocal !== null && beforeLocal !== hp) {
        const kind = type || (hp < beforeLocal ? 'dmg' : 'heal');
        flashCard(id, kind);
      }

      lastHp.set(id, hp);
    });


    socket.on('charState', ({ id, cds })=>{
      if (!charState.has(id)) initCharIfMissing(id);
      const cs = charState.get(id);
      if (cds) cs.cds = cds;
    });

    socket.on('abilityUsed', ({ kind, sourceId, targetId, name })=>{
            /* Dungeon Master Saving Throw voice */
            try{
              const __ab2 = __resolveAbilityName ? __resolveAbilityName() : (typeof name!=='undefined'?name:'');
              const _sv = String(__ab2 || '').toLowerCase().replace(/[\s_]+/g,'');
              if (_sv === 'savingthrow' && typeof playVoice === 'function'){
                playVoice('DungeonMaster_SavingThrow');
              }
            }catch(__){}
        
            /* Death Blossom Healing Blossom voice (abilityUsed) */
            try{
              const __ab = __resolveAbilityName ? __resolveAbilityName() : (typeof name!=='undefined'?name:'');
              const _hb = String(__ab || '').toLowerCase().replace(/[\s_]+/g,'');
              if (_hb === 'healingblossom' && typeof playVoice === 'function'){
                /* audio via broadcast */
              }
            }catch(__){}
        
            /* __resolveAbilityName helper */
            const __resolveAbilityName = () => {
              try{ if (typeof name !== 'undefined' && name) return name; }catch(_){}
              try{ if (typeof abilityName !== 'undefined' && abilityName) return abilityName; }catch(_){}
              try{ if (typeof ability !== 'undefined' && ability && (ability.name || ability.key)) return (ability.name || ability.key); }catch(_){}
              try{ if (typeof data !== 'undefined' && data && (data.abilityName || data.name)) return (data.abilityName || data.name); }catch(_){}
              return '';
            };
        
/* Death Blossom Healing Blossom voice */
try{
  const _hb = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_hb === 'healingblossom' && typeof playVoice === 'function'){
        if (_hb === 'healingblossom' && typeof playVoice === 'function'){
        /* audio via broadcast */
    }
}
}catch(e){}



/* Little Bear Bear Claw voice */
try{
  const _ab = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  const _fxb = (statusFX && statusFX.get) ? (statusFX.get(String(sourceId)) || {}) : {};
  const isBearNow = !!(_fxb.bear && Number(_fxb.bear) > 0);
  // Play if the ability explicitly reports 'bearclaw' OR we're transformed and using primary alias 'pawswipe'
  if (((_ab === 'bearclaw') || (_ab === 'pawswipe' && isBearNow)) && typeof playVoice === 'function'){
    playVoice('LittleBear_BearClaw');
  }
}catch(__){}
/* Little Bear Paw Swipe voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  const _fx = (statusFX && statusFX.get) ? (statusFX.get(String(sourceId)) || {}) : {};
  const isBear = !!(_fx.bear && Number(_fx.bear) > 0);
  // Only play Paw Swipe when NOT transformed
  if (_na === 'pawswipe' && !isBear && typeof playVoice === 'function'){
    playVoice('LittleBear_PawSwipe');
  }
}catch(___){}
/* Voodoo Pincushion voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'pincushion' && typeof playVoice === 'function'){
    playVoice('Voodoo_Pincushion');
  }
}catch(___){}

/* Voodoo Voodoo Doll voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'voodoodoll' && typeof playVoice === 'function'){
    playVoice('Voodoo_VoodooDoll');
  }
}catch(___){}

/* Aimbot True Shot voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'trueshot' && typeof playVoice === 'function'){
    playVoice('Aimbot_TrueShot');
  }
}catch(___){}

/* Aimbot FMJ voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'fmj' && typeof playVoice === 'function'){
    playVoice('Aimbot_FMJ');
  }
}catch(___){}

/* Don Atore Replenish voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'replenish' && typeof playVoice === 'function'){
    playVoice('DonAtore_Replenish');
  }
}catch(___){}

/* Don Atore Blood Donation voice */
try{
  const _na = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_na === 'blooddonation' && typeof playVoice === 'function'){
    playVoice('DonAtore_BloodDonation');
  }
}catch(___){}

/* Little Bear Transform voice */
try{
  const _nm = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_nm === 'transform' && typeof playVoice === 'function'){
    playVoice('LittleBear_Transform');
  }
}catch(__){}

/* Dungeon Master Skill Check voice */
try{
  const _nm = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_nm === 'skillcheck' && typeof playVoice === 'function'){
    playVoice('DungeonMaster_SkillCheck');
  }
}catch(__){}

/* Dungeon Master 1D6 voice */
try{
  const _nm = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_nm === '1d6' && typeof playVoice === 'function'){
    playVoice('DungeonMaster_1D6');
  }
}catch(__){}

  
let who = 'player1';
try {
  const token = document.querySelector(`.token[data-id="${sourceId}"]`);
  who = token ? (token.dataset.owner || 'player1') : 'player1';
  if (name) {
      try {
        window.__lastAbilityName = window.__lastAbilityName || { player1:null, player2:null };
        window.__abilityDiscardSeq = window.__abilityDiscardSeq || { player1:0, player2:0 };
        let showType = name;
        if (window.__lastAbilityName[who] === name) {
          // Alternate hidden markers so the normalized string changes every time:
          const n = (window.__abilityDiscardSeq[who] = (window.__abilityDiscardSeq[who]||0) + 1);
          const marker = (n % 2 === 1) ? '\u200B' : '\u200C'; // ZWSP / ZWNJ
          showType = name + marker;
        } else {
          window.__abilityDiscardSeq[who] = 0;
        }
        window.__lastAbilityName[who] = name;
        setDiscardByWho(who, showType);
      } catch (__) {
        setDiscardByWho(who, name);
      }
    }
} catch(e){}

/* Trickster Sleight of Hand voice */
try{
          const _n = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
          if (_n === 'sleightofhand' && typeof playVoice === 'function'){
            playVoice('Trickster_Sleight_A');
          }
    }catch(_){}

/* Trickster Swap voice */
try{
  const _n2 = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_n2 === 'swap' && typeof playVoice === 'function'){
    playVoice('Trickster_Swap');
  }
}catch(__){}

/* Loadstone Reverse Polarity voice */
try{
  const _nx = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_nx === 'reversepolarity' && typeof playVoice === 'function'){
    playVoice('Loadstone_ReversePolarity');
  }
}catch(___){}

/* Loadstone Polar Attraction voice */
try{
  const _nx = String(name || '').toLowerCase().replace(/[\s_]+/g,'');
  if (_nx === 'polarattraction' && typeof playVoice === 'function'){
    playVoice('Loadstone_PolarAttraction');
  }
}catch(___){}
if (who === playerRole){
  try{
    // Reset local Scope preview bonus immediately after an ability resolves
    window.scopeBonusNext = 0;
    // If an ability is armed, recompute its highlight with the reset range
    if (window.abilitySel){
      const { kind, sourceId } = abilitySel;
      const role = getRoleState(sourceId) || guessRoleFromId(sourceId);
      const displayName = (charState.get(sourceId)||{}).name;
      const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : ABIL_DEFS[role]);
      const def = (kind === 'primary') ? meta.primary : meta.special;
      const tok = document.querySelector(`.token[data-id="${sourceId}"]`);
      const start = tok && tok.dataset ? tok.dataset.tile : null;
      let range = (def.range ?? 1);
      const exact = (displayName === 'Aimbot' && kind === 'primary');
      let area = areaWithin(start, range, localWalls);
      if (exact && range>0){
        const inner = new Set(areaWithin(start, range-1, localWalls));
        area = area.filter(t=>!inner.has(t));
      }
      highlightSet(area, 'attack');
      abilitySel.range = range;
    }
  }catch(_){/* no-op */}
}

  if (name === 'Voodoo Doll'){
    addOrUpdateStatusLocal(sourceId, 'redirect');
  }

  try {
    if (window.abilitySel && abilitySel.kind === 'primary') {
      const btn = document.querySelector(`.charCard[data-id="${abilitySel.sourceId}"] .primaryBtn`);
      if (btn) btn.classList.add('active');
    }
  } catch(_){}
});

        socket.on('insufficientEnergy', ({ card, have, required })=>{ flashEnergyNotEnough(); });

socket.on('cardRevealed', ({ who, type })=>{ setDiscardByWho(who, type); });

    socket.on('cardPlayed', ({ type, tile, who, owner, stepsBonus, minSteps, targetId })=>{
      try{ if ((type==='BearTrap' || name==='Bear Trap' || card==='BearTrap') && tile){ trapTilesAnyOwner.add(tile); } }catch(_){ } // local energy adjust for instant-cast cards
      if (who === playerRole && CARD_COST[type]){ const now=(energyBySeat[playerRole]||0) - (CARD_COST[type]||0); energyBySeat[playerRole]=Math.max(0, now); updateEnergyBar(energyBySeat[playerRole]); }
      if (type === 'Scope' && who === playerRole){ window.scopeBonusNext = (window.scopeBonusNext||0) + 1; }
      if (who === playerRole){
        if (type === 'Sprint') moveBuff.stepsBonus = stepsBonus ?? (moveBuff.stepsBonus||0)+1; moveBuffOnce = true;
        if (type === 'Dash')     moveBuff.stepsBonus = stepsBonus ?? (moveBuff.stepsBonus||0)+2;
        if (type === 'Blink')    moveBuff.minSteps   = Math.max(moveBuff.minSteps||0, minSteps ?? 2);
      }
      if (type === 'Scout') {
        clearGhosts();
        document.querySelectorAll('.token').forEach(t=>{
          if (t.dataset.owner === playerRole) return;
          const from = t.dataset.tile;
          const hasMoved = t.dataset.hasMoved === "true";
          const r = reachable(from, hasMoved ? 1 : 2, localWalls);
          for (const tid of r) addGhost(tid, 'enemy');
        
      // Status cards quick UI update (server will reconcile on fullState)
      if (targetId){
        if (type === 'Fireball')  addOrUpdateStatusLocal(targetId, 'fireDot', 3);
        if (type === 'IronSkin')  addOrUpdateStatusLocal(targetId, 'ironSkin', 2);
        if (type === 'Entangle')  addOrUpdateStatusLocal(targetId, 'entangle', 2);
        try {
          if (typeof entangledByCard !== 'undefined' && targetId) {
            entangledByCard.add(String(targetId));
          }
          const tok = document.querySelector('.token[data-id="'+targetId+'"]');
          if (tok) { tok.classList.add('entangled'); try{ __ensureVinesOverlay(String(targetId), true); }catch(_){}}
        } catch(e) {}

                try{ entangledByCard.add(String(targetId)); const tok=document.querySelector(`.token[data-id=\"${targetId}\"]`); if (tok) tok.classList.add('entangled'); }catch(_){}
if (type === 'InvisibilityPotion') { addOrUpdateStatusLocal(targetId, 'invisible', 2); try{ applyInvisibilityOverlays(); }catch(e){} }
      }

    });

    // Bear Trap trigger: remove overlay & apply root status locally
    socket.on('trapTriggered', ({tile, targetId, rootTurns })=>{
  try{
    // Hide owner-only trap icon (if visible locally)
    try{ if (tile) hideTrapOverlay(String(tile)); }catch(_){}
    // Spawn caught overlay for both players (top layer + token class)
    try{ if (tile) showTrapCaughtOverlay(String(tile)); }catch(_){}
    try{
      if (targetId){
        addOrUpdateStatusLocal(String(targetId), 'trapped', rootTurns || 2);
        const tok = document.querySelector(`.token[data-id="${String(targetId)}"]`);
        if (tok){ tok.classList.add('trapped'); tok.dataset.rooted="true"; tok.classList.add('rooted'); }
      }
    }catch(_){}
  }catch(_){}
});


      }
            if (type === 'BearTrap' && tile && owner === playerRole) applyTrapLocal(tile);
      if (type === 'Wall' && tile) applyWallLocal(tile);
      if (type === 'BlossomWall' && tile){ const me = (owner === playerRole); (me ? applyBlossomWallLocal : applyEnemyBlossomWallLocal)(tile); neighbors(tile).forEach(tid=> (me ? applyBlossomPinkWallLocal : applyEnemyBlossomPinkWallLocal)(tid)); }
      if (type === 'Shatter' && tile) { if (!localBlossomWalls.has(tile)) removeWallLocal(tile); }
      if (who) setDiscardByWho(who, type);
    });

    socket.on('unitDied', ({ id })=>{
      const tok = document.querySelector(`.token[data-id="${id}"]`);
      if (tok) tok.remove();
      statusFX.delete(String(id));
            try{ entangledByCard.delete(String(id)); }catch(_){/*noop*/}
renderStatusRow(String(id)); try{ __reconcileTrappedOverlayFromStatus(); }catch({}){}
      if (charState.has(id)){
        const st = charState.get(id); st.hp = 0; st.dead = true; updateHPBar(id);
        flashCard(id, 'dmg');
        lastHp.set(id, 0);
      }
    });

    socket.on('gameOver', ({ winner })=>{
      GAME_ENDED = true;
      banner.style.display = 'none';
      gameover.style.display = 'flex';
      wintext.textContent = 'Game Over';
      winsub.textContent = `Winner: ${winner === 'player1' ? 'Player 1' : 'Player 2'}`;
      document.querySelectorAll('button').forEach(b=> b.disabled = true);
      playFloat.style.display = 'none';
    });
  </script>
<script>
/* === Invisibility overlay toggler (enemy POV only) === */
function applyInvisibilityOverlays(){
  try{
    if (playerRole !== 'player1' && playerRole !== 'player2') return;

    document.querySelectorAll('.token').forEach(el=>{
      const id = String(el.dataset.id||'');
      const owner = String(el.dataset.owner||'');
      const fx = (statusFX && statusFX.get && statusFX.get(id)) || {};
      const inv = fx.invisible;
      const isInvisible = !!( (typeof inv === 'number' && inv > 0) || (inv && typeof inv === 'object' && (inv.remaining||0) > 0) );
      const hideEnemy = isInvisible && owner !== playerRole;
      const ownGhost  = isInvisible && owner === playerRole;
      el.classList.toggle('invisible-to-enemy', hideEnemy);
      el.classList.toggle('invisible-own', ownGhost);
    });

    // Dim your own side panel card while invisible
    try{
      document.querySelectorAll('.charCard').forEach(card=>{
        const id = String(card.dataset.id||'');
        const st = (charState && charState.get) ? charState.get(id) : null;
        const own = !!(st && st.owner === playerRole);
        const fx = (statusFX && statusFX.get && statusFX.get(id)) || {};
        const inv = fx.invisible;
        const isInvisible = !!( (typeof inv === 'number' && inv > 0) || (inv && typeof inv === 'object' && (inv.remaining||0) > 0) );
        const dim = !!(own && isInvisible);
        card.classList.toggle('invisible-own', dim);
      });
    }catch(_){}    

  }catch(e){ /* no-op */ }
}
</script>
<script>
/* === Entangle overlay toggler === */
function updateEntangleOverlays(charsState){
  try{
    for (const [id, cs] of Object.entries(charsState||{})){
      const el = document.querySelector(`.token[data-id="${id}"]`);
      if (!el) continue;
      const ent = !!(cs.fx && cs.fx.entangle && cs.fx.entangle.remaining > 0);
      const isTrap = (typeof __trapEntangled !== 'undefined') && __trapEntangled.has(String(id));
      const show = ent && !isTrap;
      el.classList.toggle('entangled', show);
      try{ __ensureVinesOverlay(String(id), show); }catch(_){ }
    }
  }catch(e){ /* no-op */ }
}

</script>

<script>
// === Tile ring helper ===
(function(){
  const board = document.getElementById('board');
  if (!board) return;

  function tileOfToken(id){
    const el = document.querySelector('.token[data-id="'+id+'"]');
    return el ? el.dataset.tile : null;
  }
  function showTileRing(tileId){
    const p = tilePositions[tileId];
    if (!p) return;
    const s = toScreen(p.x, p.y);
    const ring = document.createElement('div');
    ring.className = 'tileRing';
    ring.style.left = s.x + 'px';
    ring.style.top  = s.y + 'px';
    board.appendChild(ring);
    setTimeout(()=> ring.remove(), 1200);
  }

  board.addEventListener('click', (e)=>{
    // Cancel Blossom special if clicking UI inside the board (buttons, cards, etc.)
    if (window.abilitySel && window.abilitySel.kind === 'special'){
      const uiHit = e.target.closest('#end-turn, .charCard, #hand, .cbtn, .primaryBtn, .specialBtn, .card, button');
      if (uiHit && !e.target.closest('.token')){
        window.abilitySel = null;
        document.querySelectorAll('.primaryBtn').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
        if (typeof clearGhosts === 'function') clearGhosts();
        return; // do not place
      }
    }
    // Only when a special is selected AND it's a 'petal' type (Death Blossom)
    try{
      const sel = abilitySel; // global from main script
      if (!sel || sel.kind !== 'special') return;

      // derive meta for the selected source
      const role = (getRoleState && sel.sourceId) ? (getRoleState(sel.sourceId) || guessRoleFromId(sel.sourceId)) : null;
      const displayName = (charState.get(sel.sourceId)||{}).name;
      const meta = (typeof getMeta==='function' ? getMeta(role, displayName) : (role && ABIL_DEFS[role]));
      const def = meta && meta.special;
      if (!def || def.type !== 'petal') return;

      // Only proceed if the click was on an actual tile element
      const __tileHit = e.target.closest('#board .hex, #board .tile, #board [data-tile], #board [data-tid]');
      if (!__tileHit) return;

      // Snap to nearest tile under the click
      const __pt = screenToBoard(e.clientX, e.clientY);
      const logicalPt = toLogical(__pt.x, __pt.y);
      const snap = nearestTile(logicalPt.x, logicalPt.y);

      const startTile = tileOfToken(sel.sourceId);
      const d = shortestDistanceWithWalls(startTile, snap.id, localWalls);
      if (d === Infinity) return;
      const rng = (def.range || sel.range || 99);
      if (d > rng) return;

      // Visual: green ring
      showTileRing(snap.id);

      // Spawn a wall using the exact Wall card path
      if (typeof socket !== 'undefined'){
        if (typeof myEnergy === 'function'){
          const need = (CARD_COST['HealingPetal']||4);
          if (myEnergy() < need){ flashEnergyNotEnough && flashEnergyNotEnough(); return; }
        }
        socket.emit('playCard', { type:'BlossomWall', tile: snap.id, origin:'blossom', sourceId: (abilitySel && abilitySel.sourceId) });
      }
      applyBlossomWallLocal(snap.id);

      // Clear selection UI
      abilitySel = null;
      document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
      clearGhosts();
    }catch(err){
      console.warn('[tile ring] error', err);
    }
  }, true); // capture to run before other handlers if any

// Global guard: if Blossom special is armed and click happens outside the board, cancel it.
document.addEventListener('click', (ev)=>{
  try{
    if (!window.abilitySel || window.abilitySel.kind !== 'special') return;
    const inBoard = ev.target.closest('#board');
    const onToken = ev.target.closest('.token');
    if (!inBoard && !onToken){
      window.abilitySel = null;
      document.querySelectorAll('.charCard').forEach(c=>c.style.outline='');
      if (typeof clearGhosts === 'function') clearGhosts();
    }
  }catch(_){}
}, true);

})();


// --- Robust guard: cancel Blossom special on any non-tile click ---
(function(){
  function cancelBlossom() {
    try{
      if (window.abilitySel && window.abilitySel.kind === 'special'){
        window.abilitySel = null;
        document.querySelectorAll('.charCard').forEach(c=> c.style.outline='');
        if (typeof clearGhosts === 'function') clearGhosts();
      }
    }catch(_){}
  }
  document.addEventListener('click', function(ev){
    if (!(window.abilitySel && window.abilitySel.kind === 'special')) return;
    const tileHit = ev.target.closest('#board .hex, #board .tile, #board [data-tile], #board [data-tid]');
    if (tileHit) return; // allow placement on real tiles only
    // Otherwise: cancel the special; also stop the board from seeing this click if it came from inside it.
    const inBoard = !!ev.target.closest('#board');
    cancelBlossom();
    if (inBoard){
      ev.stopImmediatePropagation();
      ev.stopPropagation();
    }
  }, true); // capture so we run before board handlers
})();

</script>

<script>
/* === Texture Atlas (4x6 cells from a 1024x1536 image; one full cell per hex) === */
(function(){
  const ATLAS_SRC  = 'assets/stone_atlas.png';  // 1024√ó1536
  const ATLAS_COLS = 4, ATLAS_ROWS = 6;

  // Room-based deterministic seed
  const params = new URLSearchParams(location.search);
  const ROOMID = (typeof ROOM !== 'undefined' && ROOM) ? ROOM : (params.get('room') || 'default');
  const SEED   = hashString(ROOMID + '@tex@v3');

  function applyAtlas(){
    const tiles = document.querySelectorAll('#board .tile');
    tiles.forEach((tile, i) => {
      const tw = tile.clientWidth  || parseInt(getComputedStyle(tile).width)  || 112;
      const th = tile.clientHeight || parseInt(getComputedStyle(tile).height) || 108;
      const bgW = tw * ATLAS_COLS;
      const bgH = th * ATLAS_ROWS;
      const pick = pickIndexFor(tile.dataset.id || String(i), SEED, ATLAS_COLS * ATLAS_ROWS);
      const col  = pick % ATLAS_COLS;
      const row  = Math.floor(pick / ATLAS_COLS);
      tile.style.setProperty('--atlas-w', bgW + 'px');
      tile.style.setProperty('--atlas-h', bgH + 'px');
      tile.style.setProperty('--atlas-x', -(col * tw) + 'px');
      tile.style.setProperty('--atlas-y', -(row * th) + 'px');
      tile.style.backgroundImage = `url(${ATLAS_SRC})`;
      tile.style.backgroundColor = 'transparent';
      tile.style.backgroundOrigin = 'border-box';
      tile.style.backgroundRepeat = 'no-repeat';
    });
  }

  window.addEventListener('load', applyAtlas);
  window.addEventListener('resize', () => requestAnimationFrame(applyAtlas));

  function hashString(s){let h=2166136261>>>0;for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0;}
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;};}
  function pickIndexFor(id, seed, total){const rnd=mulberry32((hashString(String(id))^seed)>>>0);return Math.floor(rnd()*total)%total;}
})();
</script>

<script>
/* DON_TAPHEAL_TOGGLE */
(function(){
  if (window.__DON_TAPHEAL__) return; window.__DON_TAPHEAL__ = true;
  function wire(){
    document.querySelectorAll('.charCard').forEach(card=>{
      const nameEl = card.querySelector('.charName'); const name = nameEl ? nameEl.textContent.trim() : '';
      if (name !== 'Don Atore') return;
      const id = card.dataset.id; const btn = card.querySelector('.cbtn.primaryBtn'); if (!btn) return;
      btn.addEventListener('mousedown', function(e){
        try{
          if (playerRole !== currentTurn || GAME_ENDED) { e.preventDefault(); e.stopImmediatePropagation(); return; }
          const role = getRoleState(id); const meta = getMeta(role, name);
          if (!meta || !meta.primary || meta.primary.type !== 'tapHeal') return;
          e.preventDefault(); e.stopImmediatePropagation();
          const on = !(window.abilitySel && window.abilitySel.sourceId === id && window.abilitySel.kind === 'primary');
          if (on){
            window.abilitySel = { sourceId:id, range: meta.primary.range || 1, kind: 'primary' };
            btn.classList.add('active');
            try{
              const tok = document.querySelector(`.token[data-id="${id}"]`);
              const tile = tok ? tok.dataset.tile : null;
              if (tile && typeof neighbors === 'function'){
                const area = new Set([tile, ...neighbors(tile)]);
                highlightSet(area, 'attack');
              }
            }catch(_){}
          } else {
            window.abilitySel = null;
            btn.classList.remove('active');
            try{ clearGhosts(); }catch(_){}
          }
        }catch(_){}
      }, true);
    });
  }
  // Wire on initial render and after any roster refresh
  wire();
  if (!window.__DON_TAPHEAL_OBS__){
    window.__DON_TAPHEAL_OBS__ = new MutationObserver(()=> wire());
    window.__DON_TAPHEAL_OBS__.observe(document.body, { childList:true, subtree:true });
  }
})();
</script>


<script id="mobileFit">
(function(){
  const board = document.getElementById('board');
  if (!board) return;

  window.UI_SCALE = 1;

  function fitBoard(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const sx = vw / 1920;
    const sy = vh / 1080;
    const scale = Math.min(sx, sy);
    window.UI_SCALE = scale;

    board.style.transformOrigin = 'top left';
    board.style.transform = 'scale(' + scale + ')';
    board.style.left = '0px';
    board.style.top  = '0px';
  }

  window.screenToBoard = function(clientX, clientY){
    const rect = board.getBoundingClientRect();
    const s = window.UI_SCALE || 1;
    return { x: (clientX - rect.left) / s, y: (clientY - rect.top) / s };
  };

  ['load','resize','orientationchange'].forEach(evt => {
    window.addEventListener(evt, fitBoard, { passive: true });
  });
  fitBoard();
})();
</script>


<script id="control-mode-ui">
(function(){
  try{
    if (typeof MODE !== 'undefined' && MODE === 'control') {
      var topBar = document.getElementById('seriesScoreTop');
      if (topBar) topBar.style.display = 'none';
      var box = document.getElementById('controlScoreBox');
      if (box) box.style.display = 'block';
    }
  }catch(e){}
})();
</script>


<!-- Non-invasive HUD locker: does not edit existing functions -->
<script id="hud-lock-noninvasive">
(function(){
  function getBoard(){ return document.getElementById('board'); }
  function getScale(){
    var b = getBoard();
    if (!b) return 1;
    var r = b.getBoundingClientRect();
    return (r.width / 1920) || 1;
  }
  function vpToBoard(x, y){
    var b = getBoard(); if (!b) return {x: x, y: y};
    var r = b.getBoundingClientRect(), s = getScale();
    return { x: (x - r.left) / s, y: (y - r.top) / s };
  }

  function lockHUD(){
    if (window.__uiLockHard) return;
    try{
      var b = getBoard(); if (!b) return;
      var s = getScale();
      var hand = document.getElementById('hand');
      var endBtn = document.getElementById('end-turn');
      var energy = document.getElementById('energyBox');
      var ally = document.getElementById('allyPanel');
      var handWrap = document.getElementById('handWrap');

      // --- End Turn: align to left of hand (viewport math), then convert to board px
      if (endBtn && hand){
        var br = b.getBoundingClientRect();
        var hr = hand.getBoundingClientRect();
        var er = endBtn.getBoundingClientRect();
        var gap_vp = 16 * s;
        var left_vp = (hr.left - br.left) - er.width - gap_vp;
        if (left_vp < 12 * s) left_vp = 12 * s;
        var left_board = left_vp / s;
        endBtn.style.position = 'absolute';
        }

      // --- Energy: place to right of ally panel and clamp above hand; convert to board px
      if (energy && ally){
        var br2 = b.getBoundingClientRect();
        var ar = ally.getBoundingClientRect();
        var hw = handWrap ? handWrap.getBoundingClientRect() : { top: window.innerHeight };
        var ebh_vp = (energy.getBoundingClientRect().height || 66 * s);
        var left_vp2 = Math.round(ar.right + 10);
        var top_vp2  = Math.round(ar.top + ar.height * 0.655);
        var maxTop_vp = hw.top - ebh_vp - 16;
        var minTop_vp = ar.top + 20;
        top_vp2 = Math.max(minTop_vp, Math.min(maxTop_vp, top_vp2));
        energy.style.position = 'absolute';
        }

      // --- Control Points: if MODE==='control' and top bar was removed, recreate a simple one
      try{
        var mode = (typeof MODE !== 'undefined') ? MODE : (new URLSearchParams(location.search).get('mode') || 'standard');
        if (mode === 'control'){
          var top = document.getElementById('seriesScoreTop');
          if (!top){
            top = document.createElement('div');
            top.id = 'seriesScoreTop';
            top.className = 'glass';
            top.style.position = 'absolute';
            top.style.left = '50%';
            top.style.top = '8px';
            top.style.transform = 'translateX(-50%)';
            top.style.zIndex = 60;
            top.innerHTML = '<div class="label">Control Points</div><div class="score"><span id="seriesP1">0</span> ‚Äî <span id="seriesP2">0</span></div>';
            // append inside board so it scales
            b.appendChild(top);
          }else{
            // if it exists but was fixed, ensure it's inside board and absolute
            if (top.parentElement !== b){ b.appendChild(top); }
            top.style.position = 'absolute';
            top.style.left = '50%';
            top.style.top = '8px';
            top.style.transform = 'translateX(-50%)';
            top.style.zIndex = 60;
            top.style.display = 'flex';
          }
        }
      }catch(e){ /* noop */ }

    }catch(e){ /* ignore placement errors */ }
  }

  // Run after the page paints, and whenever the viewport changes
  window.addEventListener('load', lockHUD);
  window.addEventListener('resize', lockHUD);
  window.addEventListener('orientationchange', lockHUD);
  // Safety: a very lightweight, infrequent correction
  setTimeout(lockHUD, 50);
  setTimeout(lockHUD, 250);
})();
</script>

<!-- Non-invasive Touch‚ÜíMouse Adapter (keeps existing code unchanged) -->



<script id="token-tap-only">
(function(){
  if (window.__CN_TokenTapOnly) return; window.__CN_TokenTapOnly = true;
  var isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  if (!isTouch) return;
  var board = document.getElementById('board'); if (!board) return;

  // Active only when an ability is armed; turns touch on a token into a clean click
  function abilityActive(){ try { return !!(window.abilitySel); } catch(_) { return false; } }

  var arming = false;
  board.addEventListener('pointerdown', function(e){
    if (!abilityActive()) return;
    if (e.pointerType !== 'touch') return;
    if (!e.target.closest('.token')) return;
    arming = true;
    e.preventDefault(); e.stopPropagation();
  }, true);

  document.addEventListener('pointerup', function(e){
    if (!arming) return;
    if (e.pointerType !== 'touch') { arming = false; return; }
    var el = document.elementFromPoint(e.clientX, e.clientY);
    var tok = el && el.closest ? el.closest('.token') : null;
    if (tok){
      tok.dispatchEvent(new MouseEvent('click', { bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY, view:window }));
    }
    e.preventDefault(); e.stopPropagation();
    arming = false;
  }, true);
})();
</script>


<script id="token-drag-touch">
(function(){
  if (window.__CN_TokenDragTouch) return; window.__CN_TokenDragTouch = true;
  var isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  if (!isTouch) return;
  var board = document.getElementById('board'); if (!board) return;

  function abilityActive(){ try { return !!(window.abilitySel); } catch(_) { return false; } }

  var dragging = false;
  var targetEl = null;

  function wantsToken(el){
    return el && el.closest && el.closest('.token');
  }

  document.addEventListener('pointerdown', function(e){
    if (e.pointerType !== 'touch') return;
    if (abilityActive()) return; // targeting handled by token-tap-only
    var tok = wantsToken(e.target);
    if (!tok) return;

    targetEl = tok;
    dragging = true;

    // Begin the normal mouse drag sequence at this point
    var down = new MouseEvent('mousedown', { bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY, view:window, buttons:1 });
    targetEl.dispatchEvent(down);

    e.preventDefault(); e.stopPropagation();
  }, true);

  document.addEventListener('pointermove', function(e){
    if (!dragging) return;
    if (e.pointerType !== 'touch') return;

    // Continue drag
    var move = new MouseEvent('mousemove', { bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY, view:window, buttons:1 });
    document.dispatchEvent(move);

    e.preventDefault(); e.stopPropagation();
  }, true);

  function endDrag(e){
    if (!dragging) return;
    if (e.pointerType && e.pointerType !== 'touch') return;

    var up = new MouseEvent('mouseup', { bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY, view:window });
    document.dispatchEvent(up);

    dragging = false;
    targetEl = null;

    e.preventDefault(); e.stopPropagation();
  }

  document.addEventListener('pointerup', endDrag, true);
  document.addEventListener('pointercancel', endDrag, true);
})();
</script>
<!-- Hard-expiry v2 for BearTrap overlays (authoritative client cleanup) -->
<script id="trap-hard-expiry" data-version="2">
(function(){
  if (window.__TRAP_HARD_EXPIRY_V2__) return;
  window.__TRAP_HARD_EXPIRY_V2__ = true;

  // Debug flag: set true to see console logs
  const DEBUG = false;
  function log(){ if (DEBUG && console && console.debug) console.debug("[TRAP-EXPIRY]", ...arguments); }

  // Canonical maps (globals we maintain)
  const forceExpireAtTick = (window.forceExpireAtTick ||= new Map()); // tileId -> absolute tick when to delete
  const expireStartTick   = (window.expireStartTick   ||= new Map()); // tileId -> tick when set
  const trapOverlays      = (window.trapOverlays      ||= new Map());
  const trapCaughtOverlays= (window.trapCaughtOverlays||= new Map());
  const trapSuppressedLocal = (window.trapSuppressedLocal ||= new Set());
  const trapPlacedAtTick  = (window.trapPlacedAtTick  ||= new Map());
  const trapTilesAnyOwner = (window.trapTilesAnyOwner ||= new Set());
  const localTraps        = (window.localTraps        ||= new Set());

  function qselAllForTile(tileId){
    const tid = String(tileId);
    const a = Array.from(document.querySelectorAll('.trap-overlay[title="'+tid+'"]'));
    const b = Array.from(document.querySelectorAll('.trap-caught[title="'+tid+'"]'));
    return a.concat(b);
  }

  function forceRemoveTrapTile(tileId){
    const tid = String(tileId);
    try{
      // purge DOM by map handle
      try{ const el = trapOverlays.get(tid); if (el && el.remove) el.remove(); }catch(_){}
      trapOverlays.delete(tid);
      try{ const el2 = trapCaughtOverlays.get(tid); if (el2 && el2.remove) el2.remove(); }catch(_){}
      trapCaughtOverlays.delete(tid);

      // purge DOM by selector fallback
      for (const el of qselAllForTile(tid)){ try{ el.remove(); }catch(_){} }

      // prevent re-add from reconcile/fullstate
      trapSuppressedLocal.add(tid);
      try{ if (window.trapTTL && trapTTL.delete) trapTTL.delete(tid); }catch(_){}
      trapPlacedAtTick.delete(tid);
      trapTilesAnyOwner.delete(tid);
      localTraps.delete(tid);
      forceExpireAtTick.delete(tid);
      expireStartTick.delete(tid);
      log("Removed overlay for", tid);
    }catch(e){ log("forceRemoveTrapTile error", e); }
  }

  function nowTick(){ try{ return (window.__turnTick|0); }catch(_){ return 0; } }

  function gcTrapOverlays(){
    const now = nowTick();
    try{
      for (const [tid, exp] of Array.from(forceExpireAtTick.entries())){
        if (now >= (exp|0)){
          forceRemoveTrapTile(tid);
        }
      }
    }catch(e){ log("gc error", e); }

    // Extra safety: any trap overlay older than 4 ticks from placement must go
    try{
      document.querySelectorAll('.trap-overlay').forEach(el=>{
        const tid = el && el.getAttribute('title');
        if (!tid) return;
        const placed = (trapPlacedAtTick.get(tid) ?? expireStartTick.get(tid) ?? 0)|0;
        if (now - placed >= 4){
          forceRemoveTrapTile(tid);
        }
      });
    }catch(_){}
  }

  // Hook trap trigger to start a 4-turn expiry window
  if (window.socket && window.socket.on){
    window.socket.on('trapTriggered', ({ tile })=>{
      try{
        const tid = String(tile);
        const base = nowTick();
        expireStartTick.set(tid, base);
        forceExpireAtTick.set(tid, base + 4);
        // make sure original icon is allowed to be seen during the window
        try{ trapSuppressedLocal.delete(tid); }catch(_){}
        // ensure it's visible now if your logic expects that
        try{ if (typeof showTrapOverlay === 'function') showTrapOverlay(tid); }catch(_){}
        log("trigger -> expire at", tid, base+4);
      }catch(e){ log("trapTriggered hook err", e); }
    });

    // On every turn, run GC pass (we DO NOT change __turnTick here)
    window.socket.on('nextTurn', ()=>{ setTimeout(gcTrapOverlays, 0); });
  }

  // Patch reconcile and showTrapOverlay to respect expiry
  const _recon = window.reconcileTrapOverlays;
  window.reconcileTrapOverlays = function(list){
    try{
      const now = nowTick();
      if (Array.isArray(list)){
        for (const entry of list){
          const tid = String(entry && (entry.tile || entry));
          const exp = forceExpireAtTick.get(tid);
          if ((exp!=null && now >= (exp|0)) || ((trapPlacedAtTick.has(tid)) && ((now - (trapPlacedAtTick.get(tid)|0)) >= 4))){
            forceRemoveTrapTile(tid);
          }
        }
      }
    }catch(_){}
    try{ return _recon && _recon.apply(this, arguments); }catch(_){ return undefined; }
  };

  const _show = window.showTrapOverlay;
  window.showTrapOverlay = function(tileId){
    const tid = String(tileId);
    const now = nowTick();
    const exp = forceExpireAtTick.get(tid);
    if (exp!=null && now >= (exp|0)){
      // refuse to show expired overlays
      forceRemoveTrapTile(tid);
      return;
    }
    return _show && _show.apply(this, arguments);
  };

  // As an absolute last resort, run a timer sweep
  // Debug helpers
  window.forceExpireTrapNow = function(tileId){
    const tid = String(tileId);
    forceExpireAtTick.set(tid, nowTick()); gcTrapOverlays();
  };
  window.nukeAllTraps = function(){
    try{
      const tiles = new Set();
      document.querySelectorAll('.trap-overlay,.trap-caught').forEach(el=>{ const t=el.getAttribute('title'); if (t) tiles.add(t); });
      for (const t of tiles) forceRemoveTrapTile(t);
    }catch(_){}
  };
  setInterval(gcTrapOverlays, 400);
})();</script>

<script>
(function(){
  if (!window.__TRAP_CLEAR_LISTENER__) {
    window.__TRAP_CLEAR_LISTENER__ = true;
    try {
      socket.on('trapCleared', ({ tiles })=>{
        try{
          (tiles||[]).forEach(tid=>{
            try{ hideTrapOverlay(String(tid)); }catch(_){}
            try{
              // also remove any 'caught' image
              if (window.trapCaughtOverlays && trapCaughtOverlays.get && trapCaughtOverlays.has(String(tid))){
                const el = trapCaughtOverlays.get(String(tid)); if (el && el.remove) el.remove();
                trapCaughtOverlays.delete(String(tid));
              }
            }catch(_){}
          });
        }catch(_){}
      });
    } catch(_){ /* ignore */ }
  }
})();

/* === Reconcile only card-based entangle overlays === */
function __reconcileEntangleVinesFromCard(){
  try{
    const ids = Array.from(entangledByCard);
    for (const id of ids){
      const fx = (statusFX && statusFX.get) ? (statusFX.get(String(id))||{}) : {};
      const active = !!( (typeof fx.entangle === 'number' && fx.entangle > 0) ||
                         (fx.entangle && typeof fx.entangle === 'object' && (fx.entangle.remaining||0) > 0) );
      const tok = document.querySelector(`.token[data-id="${id}"]`);
      if (tok) tok.classList.toggle('entangled', active);
      if (!active){ entangledByCard.delete(String(id)); }
    }
  }catch(e){ /* no-op */ }
}

/* === Vines overlay management (robust) === */
const __vinesElById = new Map();      // id -> DOM element appended to token
const __trapEntangled = new Set();    // ids entangled by Bear Trap

function __ensureVinesOverlay(id, shouldShow){
  const tok = document.querySelector(`.token[data-id="${id}"]`);
  if (!tok) return;
  let el = __vinesElById.get(String(id));
  if (shouldShow){
    if (!el){
      el = document.createElement('div');
      el.className = 'vinesOverlay';
      __vinesElById.set(String(id), el);
      tok.appendChild(el);
    }
  }else{
    if (el){
      el.remove();
      __vinesElById.delete(String(id));
    }
  }
}

// Track trap roots so vines don't show for bear traps
try{
  socket.on('trapTriggered', ({ targetId })=>{
    try { if (targetId != null) __trapEntangled.add(String(targetId)); } catch(_){}
  });
} catch(_){}

/* Reconcile vines on any entangle status, excluding trap-based roots */
function __reconcileVinesFromStatus(){
  try{
    document.querySelectorAll('.token').forEach(tok=>{
      const id = String(tok.dataset.id);
      const fx = (statusFX && statusFX.get) ? (statusFX.get(id) || {}) : {};
      const active = (typeof fx.entangle === 'number' && fx.entangle > 0);
      const show = active && !__trapEntangled.has(id);
      __ensureVinesOverlay(id, show);
      // keep legacy .entangled class for any code that looks for it
      tok.classList.toggle('entangled', show);
      if (!active){
        __trapEntangled.delete(id);
        if (typeof entangledByCard !== 'undefined') entangledByCard.delete(id);
      }
    });
  }catch(e){}
}
setInterval(__reconcileVinesFromStatus, 250);
</script>








<style id="trapCaughtLayerTopFix">
  #trapCaughtLayer{ position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index:2147483647 !important; }
  .trap-caught{ pointer-events:none; }
</style>


<script id="volumeControl">
(function(){
  const bgm = document.getElementById('bgmAudio');
  const wrap = document.getElementById('volWrap');
  if (!bgm) return;

  if (bgm.__baseVol == null) bgm.__baseVol = 0.05;

  const saved = parseFloat(localStorage.getItem('cn_volume') || '1');
  window.__CN_VOL = isFinite(saved) ? Math.max(0, Math.min(2, saved)) : 1;

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function applyBgm(){
    try{
      bgm.muted = false;
      bgm.volume = clamp01(bgm.__baseVol * window.__CN_VOL);
    }catch(_){}
  }

  function applyVoiceVolumes(){
    try{
      if (!window.VOICES) return;
      Object.values(VOICES).forEach(a=>{
        if (!a) return;
        if (a.__baseVol == null) a.__baseVol = (typeof a.volume === 'number' ? a.volume : 1);
        a.volume = clamp01(a.__baseVol * window.__CN_VOL);
      });
    }catch(_){}
  }

  function reflectUI(){
    const slider = document.getElementById('volSlider');
    const label  = document.getElementById('volLabel');
    if (!slider || !label) return;
    slider.value = String(window.__CN_VOL);
    label.textContent = 'Sounds';
  }

  function setVol(mult){
    window.__CN_VOL = Math.max(0, Math.min(2, parseFloat(mult) || 0));
    localStorage.setItem('cn_volume', String(window.__CN_VOL));
    sessionStorage.setItem('cn_volume', String(window.__CN_VOL));
    applyVoiceVolumes();
    applyBgm();
    reflectUI();
  }

  function armUI(){
    if (!wrap) return;
    wrap.style.display = 'flex';
    const slider = document.getElementById('volSlider');
    if (slider){ slider.addEventListener('input', e=> setVol(e.target.value)); }
    reflectUI();
  }

  (function armSocket(){
    try{
      if (typeof socket === 'undefined' || !socket || !socket.on){ setTimeout(armSocket, 120); return; }
      socket.on('assignRole', (role)=>{
        if (role === 'player1' || role === 'player2'){
          armUI();
          applyVoiceVolumes();
          applyBgm();
          bgm.play().catch(()=>{});
        }
      });
      socket.on('gameOver', ()=>{
        try{ bgm.pause(); bgm.currentTime = 0; }catch(_){}
      });
    }catch(_){ setTimeout(armSocket, 150); }
  })();

  document.addEventListener('pointerdown', ()=>{
    if (bgm.paused){ bgm.play().catch(()=>{}); }
  });

  applyVoiceVolumes(); applyBgm(); reflectUI();
  window.setCNVolume = setVol;
})();
</script>


<!-- HB_TILE_GATED -->
<script>
(function(){
  try{
    var HB = { armed:false, tileClicked:false, listener:null, lastPlay:0 };

    function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
    function isHB(nameLike){
      var n = norm(nameLike);
      return (n === 'healingblossom' || n === 'healingbloom' || n === 'blossom');
    }
    function resolveAbility(p){
      try{
        if (p && p.name) return p.name;
        if (p && p.abilityName) return p.abilityName;
        if (p && p.ability && (p.ability.name || p.ability.key)) return (p.ability.name || p.ability.key);
        if (p && p.data && (p.data.abilityName || p.data.name)) return (p.data.abilityName || p.data.name);
      }catch(_){}
      return '';
    }
    function playHB(){
      var now = Date.now();
      if (now - HB.lastPlay < 200) return; // small dedupe
      HB.lastPlay = now;
      if (typeof playVoice === 'function'){
        try { /* audio via broadcast */ return; } catch(_){}
      }
      // Do not add any new audio paths; rely on existing VOICES entries only
    }

    function attachTileListener(){
      if (HB.listener) return;
      HB.listener = function(ev){
        try{
          var tile = ev.target && ev.target.closest ? ev.target.closest('.tile') : null;
          if (tile){ HB.tileClicked = true; }
        }catch(_){}
      };
      var board = document.getElementById('board');
      if (board && board.addEventListener){
        board.addEventListener('click', HB.listener, true);
      }
    }
    function detachTileListener(){
      try{
        var board = document.getElementById('board');
        if (HB.listener && board && board.removeEventListener){
          board.removeEventListener('click', HB.listener, true);
        }
      }catch(_){}
      HB.listener = null;
    }

    function arm(){ HB.armed = true; HB.tileClicked = false; attachTileListener(); }
    function disarm(){ HB.armed = false; HB.tileClicked = false; detachTileListener(); }

    // Wrap selectAbility to arm only when Healing Blossom special is pressed
    var _selectAbility = window.selectAbility;
    if (typeof _selectAbility === 'function'){
      window.selectAbility = function(kind, sourceId){
        try{
          if (kind === 'special'){
            var role = (typeof getRoleState==='function' ? getRoleState(sourceId) : null) || (typeof guessRoleFromId==='function' ? guessRoleFromId(sourceId) : null);
            var displayName = (window.charState && charState.get && charState.get(sourceId) && charState.get(sourceId).name) || '';
            var meta = (typeof getMeta==='function' ? getMeta(role, displayName) : null);
            var def = meta && meta.special;
            var sName = norm(def && def.name);
            if (isHB(sName) || (def && def.type === 'petal')){
              arm();
            }else{
              disarm();
            }
          }else{
            disarm();
          }
        }catch(_){}
        return _selectAbility.apply(this, arguments);
      };
    }

    // Only play after we see both: a tile click (post-arm) and the server's abilityUsed for HB
    if (window.socket && typeof socket.on === 'function'){
      socket.on('abilityUsed', function(payload){
        try{
          if (!HB.armed) return;
          if (!HB.tileClicked) return; // must have clicked a tile after arming
          var ab = resolveAbility(payload);
          if (isHB(ab)){
            playHB();
            disarm();
          }
        }catch(_){}
      });
    }
  }catch(_){}
})();
</script>

<script>
// === Healing Blossom: simple client-side audio gate ===
// Plays only when: (a) Death Blossom's Special is selected, (b) a board tile is clicked,
// (c) your energy is >= the Special's energyCost. Purely client-side audio; server is authoritative.
(function(){
  if (window.__hbVoiceHookInstalled) return;
  window.__hbVoiceHookInstalled = true;

  function isDeathBlossomSpecial(sel){
    try{
      if (!sel || sel.kind !== 'special') return false;
      const id = sel.sourceId;
      if (!id) return false;
      const st = (typeof charState!=='undefined' && charState.get) ? charState.get(String(id)) : null;
      const name = st && st.name ? String(st.name) : "";
      if (name !== 'Death Blossom') return false;
      const role = (typeof getRoleState==='function') ? getRoleState(String(id)) : (typeof guessRoleFromId==='function' ? guessRoleFromId(String(id)) : 'Support');
      const meta = (typeof getMeta==='function') ? getMeta(role, name) : null;
      const spec = meta && meta.special ? meta.special : null;
      if (!spec) return false;
      const specName = (spec.name || '').toLowerCase();
      return (specName.includes('healing') || specName.includes('blossom') || spec.type === 'petal');
    }catch(_){ return false; }
  }

  function myCurrentEnergy(){
    try {
      if (typeof myEnergy === 'function') return myEnergy();
      if (typeof energyBySeat !== 'undefined' && energyBySeat && playerRole) return energyBySeat[playerRole] || 0;
      return 0;
    } catch(_){ return 0; }
  }

  function currentSpecialCostFor(id){
    try{
      const st = (typeof charState!=='undefined' && charState.get) ? (charState.get(String(id)) || {}) : {};
      const role = (typeof getRoleState==='function') ? getRoleState(String(id)) : (typeof guessRoleFromId==='function' ? guessRoleFromId(String(id)) : 'Support');
      const meta = (typeof getMeta==='function') ? getMeta(role, st.name) : null;
      const spec = meta && meta.special ? meta.special : null;
      return (spec && spec.energyCost) ? Number(spec.energyCost) : 0;
    }catch(_){ return 0; }
  }

  document.addEventListener('click', function(ev){
    try{
      const tileEl = ev.target.closest ? ev.target.closest('.tile') : null;
      if (!tileEl) return;
      if (typeof abilitySel === 'undefined' || !abilitySel) return;
      if (!isDeathBlossomSpecial(abilitySel)) return;

      const cost = currentSpecialCostFor(abilitySel.sourceId);
      const have = myCurrentEnergy();

      if (have >= cost){
        if (typeof playVoice === 'function') /* audio via broadcast */
      } else {
        try{ if (typeof flashEnergyNotEnough==='function') flashEnergyNotEnough(); }catch(_){}
      }
    }catch(_){ /* swallow */ }
  }, true);
})();
</script>


<script id="bgmToggleClearOffsets">
  // === ChatGPT update: clear stale offset for BGM toggle ===
  try { localStorage.removeItem('bgmToggleOffset'); } catch (e) {}
</script>


<!-- ===== Voice Consistency Engine (VCE) ===== -->
<script>
(function(){
  // Lightweight utility
  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
  function clamp(n,min,max){ return n<min?min:(n>max?max:n); }

  // ---- CONFIG (extend freely as you add heroes/abilities) ------------------
  const VCONF = {
    // Map normalized ability name -> VOICES key
    abilityToKey: {
      'nectaroflife': 'NectarOfLife',
      'mend'        : 'NectarOfLife',
      'healingblossom': 'DeathBlossom_HealingBlossom',
      'healingbloom'  : 'DeathBlossom_HealingBlossom',
      'blossom'       : 'DeathBlossom_HealingBlossom',
    },
    // Map hero:kind -> VOICES key (both normalized)
    heroKindToKey: {
      'deathblossom:primary': 'NectarOfLife',
      'deathblossom:special': 'DeathBlossom_HealingBlossom',
    },
    // Server events that may carry ability usage
    abilityEvents: ['abilityUsed','ability-used','server:abilityUsed','server:ability-used'],
    // Dedupe window (ms) to avoid double audio if legacy handlers also play
    dedupeMs: 350
  };

  // ---- Robust payload resolution ------------------------------------------
  function resolveAbility(p){
    try{
      return p?.name || p?.abilityName ||
             p?.ability?.name || p?.ability?.key ||
             p?.data?.abilityName || p?.data?.name || '';
    }catch(_){ return ''; }
  }
  function resolveKind(p){
    try{
      return p?.kind || p?.ability?.kind || p?.ability?.type || p?.type || '';
    }catch(_){ return ''; }
  }
  function resolveSourceId(p){
    try{
      return (p?.sourceId != null ? String(p.sourceId) :
              p?.source?.id != null ? String(p.source.id) :
              p?.actorId != null ? String(p.actorId) : '');
    }catch(_){ return ''; }
  }
  function resolveHeroByPayload(p){
    try{
      return p?.hero || p?.heroName || p?.sourceHero || p?.sourceHeroName ||
             p?.source?.hero?.name || p?.source?.name || p?.actor?.name || '';
    }catch(_){ return ''; }
  }
  function resolveHeroBySourceId(p){
    try{
      const sid = resolveSourceId(p);
      if (sid && window.charState && typeof window.charState.get === 'function'){
        const cs = window.charState.get(sid);
        return cs && cs.name || '';
      }
    }catch(_){}
    return '';
  }
  function resolveHero(p){
    return resolveHeroByPayload(p) || resolveHeroBySourceId(p) || '';
  }

  // ---- Safe local playback that respects THIS client's slider --------------
  function safePlay(key){
    try{
      // Prefer app's provided playVoice if available (handles user slider)
      if (typeof window.playVoice === 'function'){
        window.playVoice(key);
        return;
      }
      // Fallback: play via VOICES map if present
      const VOICES = window.VOICES || window.Voices || window.voices;
      const a = VOICES && VOICES[key];
      if (a && typeof a.play === 'function'){
        try { a.pause(); } catch(_){}
        try { a.currentTime = 0; } catch(_){}
        // Apply best-effort volume multiplier if exposed
        try{
          const baseVol = (typeof a.volume === 'number' ? a.volume : 1);
          const slider  = (typeof window.__CN_VOL === 'number' ? window.__CN_VOL : 1);
          a.volume = clamp(baseVol * slider, 0, 1);
        }catch(_){}
        a.play().catch(function(){});
      }
    }catch(_){}
  }

  // ---- Dedupe to avoid stacked audio --------------------------------------
  const _memo = {};
  function playOnce(key, ms){
    const now = Date.now();
    const win = (ms || VCONF.dedupeMs);
    if (_memo[key] && now - _memo[key] < win) return;
    _memo[key] = now;
    safePlay(key);
  }

  // ---- Ability routing -----------------------------------------------------
  function routeVoice(payload){
    const ab = norm(resolveAbility(payload));
    const kind = norm(resolveKind(payload));
    const hero = norm(resolveHero(payload));

    // 1) Ability-name mapping (most reliable when present)
    if (ab && VCONF.abilityToKey[ab]){
      playOnce(VCONF.abilityToKey[ab]);
      return true;
    }
    // 2) Hero+kind mapping (covers cases where ability name is missing)
    if (hero && kind){
      const hk = hero + ':' + kind;
      if (VCONF.heroKindToKey[hk]){
        playOnce(VCONF.heroKindToKey[hk]);
        return true;
      }
    }
    return false;
  }

  // ---- Event binding (non-invasive) ---------------------------------------
  function attach(){
    const s = window.socket;
    if (!s || typeof s.on !== 'function') return false;
    VCONF.abilityEvents.forEach(function(evt){
      try{ s.on(evt, routeVoice); }catch(_){}
    });
    return true;
  }

  // ---- Autoplay unlock (first user gesture warms audio) -------------------
  function unlockOnce(){
    if (unlockOnce._did) return;
    unlockOnce._did = true;
    try{
      const keys = ['NectarOfLife','DeathBlossom_HealingBlossom'];
      const VOICES = window.VOICES || window.Voices || window.voices || {};
      keys.forEach(function(k){
        const a = VOICES[k];
        if (a && typeof a.play === 'function'){
          // Attempt a silent pre-play to satisfy autoplay policies; ignore errors
          try{ a.muted = true; a.play().then(()=>{ a.pause(); a.currentTime = 0; a.muted = false; }).catch(()=>{}); }catch(_){}
        }
      });
    }catch(_){}
  }
  window.addEventListener('pointerdown', unlockOnce, { once:true, capture:true });
  window.addEventListener('keydown', unlockOnce, { once:true, capture:true });

  // ---- Initialize ----------------------------------------------------------
  if (!attach()){
    let tries = 0;
    const iv = setInterval(function(){
      tries++;
      if (attach() || tries > 120){ // ~6s @50ms
        clearInterval(iv);
      }
    }, 50);
  }
})();
</script>
<!-- ===== /Voice Consistency Engine (VCE) ===== -->


<!-- DB_VOICE_HARDLINK -->
<script>
(function(){
  const TAG = '[DB-VoiceHardLink]';
  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
  function resolveAbility(p){
    try{
      return p?.name || p?.abilityName || p?.ability?.name || p?.ability?.key || p?.data?.abilityName || p?.data?.name || '';
    }catch(_){ return ''; }
  }
  function resolveKind(p){
    try{ return p?.kind || p?.ability?.kind || p?.ability?.type || p?.type || ''; }catch(_){ return ''; }
  }
  function resolveSourceId(p){
    try{
      return (p?.sourceId != null ? String(p.sourceId) :
              p?.source?.id != null ? String(p.source.id) :
              p?.actorId != null ? String(p.actorId) : '');
    }catch(_){ return ''; }
  }
  function heroFromStateBySourceId(p){
    try{
      const sid = resolveSourceId(p);
      const cs = sid && window.charState && window.charState.get && window.charState.get(String(sid));
      return cs && cs.name || '';
    }catch(_){ return ''; }
  }
  function resolveHero(p){
    try{
      return p?.hero || p?.heroName || p?.sourceHero || p?.sourceHeroName ||
             p?.source?.hero?.name || p?.source?.name || p?.actor?.name || '' || heroFromStateBySourceId(p);
    }catch(_){ return heroFromStateBySourceId(p); }
  }
  function looksLikeDB(payload){
    const ab = norm(resolveAbility(payload));
    const hero = norm(resolveHero(payload));
    return (hero === 'deathblossom') ||
           (ab === 'healingblossom' || ab === 'healingbloom' || ab === 'blossom' || ab === 'nectaroflife' || ab === 'mend');
  }
  function selectKey(payload){
    const ab = norm(resolveAbility(payload));
    const kind = norm(resolveKind(payload));
    if (ab === 'nectaroflife' || ab === 'mend' || kind === 'primary') return 'NectarOfLife';
    if (ab === 'healingblossom' || ab === 'healingbloom' || ab === 'blossom' || kind === 'special') return 'DeathBlossom_HealingBlossom';
    return null;
  }
  function now(){ return Date.now(); }

  // Hard-play: attempt up to 3 times in short succession.
  function hardPlay(key){
    const attempts = [0, 150, 400];
    attempts.forEach((delay,i)=>{
      setTimeout(function(){
        try{
          if (typeof window.playVoice === 'function'){ window.playVoice(key); }
          else {
            const VOICES = window.VOICES || window.voices || window.Voices || {};
            const a = VOICES[key];
            if (a && typeof a.play === 'function'){
              if (a.__baseVol == null) a.__baseVol = (typeof a.volume === 'number' ? a.volume : 1);
              const mult = (typeof window.__CN_VOL === 'number' ? window.__CN_VOL : 1);
              a.volume = Math.max(0, Math.min(1, a.__baseVol * mult));
              try{ a.pause(); a.currentTime = 0; }catch(_){}
              a.muted = false;
              a.play().catch(()=>{});
            }
          }
          if (window.__DEV_LOG_DB) console.log(TAG, 'played', key, 'attempt', i+1);
        }catch(_){
          if (window.__DEV_LOG_DB) console.log(TAG, 'play error', key, _);
        }
      }, delay);
    });
  }

  function attach(){
    const s = window.socket;
    if (!s || (typeof s.on !== 'function')) return false;

    // Prefer onAny if available (captures all ability events regardless of custom name)
    if (typeof s.onAny === 'function'){
      s.onAny(function(evt, payload){
        try{
          if (evt && String(evt).toLowerCase().includes('ability')){
            if (!looksLikeDB(payload)) return;
            const key = selectKey(payload);
            if (key){ hardPlay(key); }
          }
        }catch(_){}
      });
    }

    // Also bind the canonical names
    ['abilityUsed','ability-used','server:abilityUsed','server:ability-used'].forEach(function(evt){
      try{
        s.on(evt, function(payload){
          try{
            if (!looksLikeDB(payload)) return;
            const key = selectKey(payload);
            if (key){ hardPlay(key); }
          }catch(_){}
        });
      }catch(_){}
    });

    return true;
  }

  if (!attach()){
    let tries = 0;
    const iv = setInterval(function(){
      tries++;
      if (attach() || tries > 200) clearInterval(iv);
    }, 50);
  }
})();
</script>


<!-- VOICE_BROADCAST_DB_UNIFIED -->
<script>
(function(){
  if (!window.socket || typeof socket.on !== 'function') return;
  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
  function resolveAbility(p){
    try{
      return p?.name || p?.abilityName ||
             p?.ability?.name || p?.ability?.key ||
             p?.data?.abilityName || p?.data?.name || '';
    }catch(_){ return ''; }
  }
  function resolveKind(p){
    try{ return p?.kind || p?.ability?.kind || p?.ability?.type || p?.type || ''; }catch(_){ return ''; }
  }
  function resolveSourceId(p){
    try{
      return (p?.sourceId != null ? String(p.sourceId) :
              p?.source?.id != null ? String(p.source.id) :
              p?.actorId != null ? String(p.actorId) : '');
    }catch(_){ return ''; }
  }
  function resolveHeroByPayload(p){
    try{
      return p?.hero || p?.heroName || p?.sourceHero || p?.sourceHeroName ||
             p?.source?.hero?.name || p?.source?.name || p?.actor?.name || '';
    }catch(_){ return ''; }
  }
  function resolveHeroBySourceId(p){
    try{
      const sid = resolveSourceId(p);
      if (sid && window.charState && typeof window.charState.get === 'function'){
        const cs = window.charState.get(sid);
        return cs && cs.name || '';
      }
    }catch(_){}
    return '';
  }
  function resolveHero(p){ return resolveHeroByPayload(p) || resolveHeroBySourceId(p) || ''; }

  const _memo = {};
  function playOnce(key){
    const now = Date.now();
    if (_memo[key] && now - _memo[key] < 350) return;
    _memo[key] = now;
    try{ if (typeof playVoice === 'function') playVoice(key); }catch(_){}
  }

  function onAbility(payload){
    try{
      const ab = norm(resolveAbility(payload));
      const kind = norm(resolveKind(payload));
      const hero = norm(resolveHero(payload));

      // Prefer ability name
      if (ab === 'healingblossom' || ab === 'healingbloom' || ab === 'blossom'){
        playOnce('DeathBlossom_HealingBlossom'); return;
      }
      if (ab === 'nectaroflife' || ab === 'mend'){
        playOnce('NectarOfLife'); return;
      }

      // Fallback: hero + kind
      if (norm(hero) === 'deathblossom'){
        if (kind === 'special') playOnce('DeathBlossom_HealingBlossom');
        else if (kind === 'primary') playOnce('NectarOfLife');
      }
    }catch(_){}
  }

  ['abilityUsed','ability-used','server:abilityUsed','server:ability-used'].forEach(function(evt){
    try{ socket.on(evt, onAbility); }catch(_){}
  });
})();
</script>


<!-- CN_VOICE_FINAL -->
<script>
(function(){
  // Normalize utility
  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }

  // Decide the VOICE key to play based on payload
  function pickVoiceKey(payload){
    try{
      const ab = norm(payload?.name || payload?.abilityName || payload?.ability?.name || payload?.ability?.key || payload?.data?.abilityName || payload?.data?.name);
      const kind = norm(payload?.kind || payload?.ability?.kind || payload?.ability?.type || payload?.type);
      // Ability name path first
      if (ab === 'healingblossom' || ab === 'healingbloom' || ab === 'blossom') return 'DeathBlossom_HealingBlossom';
      if (ab === 'nectaroflife' || ab === 'mend') return 'NectarOfLife';
      // Fallback to hero+kind
      const sid = (payload?.sourceId != null ? String(payload.sourceId) : (payload?.source?.id != null ? String(payload.source.id) : ''));
      let hero = norm(payload?.hero || payload?.heroName || payload?.sourceHero || payload?.sourceHeroName || payload?.source?.hero?.name || payload?.source?.name || payload?.actor?.name || '');
      if (!hero && sid && window.charState && typeof window.charState.get === 'function'){
        try{
          const cs = window.charState.get(String(sid));
          hero = norm(cs && cs.name);
        }catch(_){}
      }
      if (hero === 'deathblossom'){
        if (kind === 'special') return 'DeathBlossom_HealingBlossom';
        if (kind === 'primary') return 'NectarOfLife';
      }
    }catch(_){}
    return null;
  }

  // Safe local playback respecting THIS tab's slider
  function playLocal(key){
    try{
      if (typeof window.playVoice === 'function'){ window.playVoice(key); return; }
      const VOICES = window.VOICES || window.voices || window.Voices || {};
      const a = VOICES[key];
      if (!a || typeof a.play !== 'function') return;
      if (a.__baseVol == null) a.__baseVol = (typeof a.volume === 'number' ? a.volume : 1);
      const mult = (typeof window.__CN_VOL === 'number' ? window.__CN_VOL : 1);
      a.volume = Math.max(0, Math.min(1, a.__baseVol * mult));
      try{ a.pause(); a.currentTime = 0; }catch(_){}
      a.muted = false;
      a.play().catch(()=>{});
    }catch(_){}
  }

  // Dedupe on event signature to avoid stacking
  const seen = new Map();
  function sigOf(evt, payload){
    const id = (payload && (payload.id || payload.uuid || payload.eventId || payload.ts || payload.time)) || '';
    const ab = norm(payload?.name || payload?.abilityName || payload?.ability?.name || payload?.ability?.key || payload?.data?.abilityName || payload?.data?.name);
    const k  = norm(payload?.kind || payload?.ability?.kind || payload?.ability?.type || payload?.type);
    const s  = (payload?.sourceId != null ? String(payload.sourceId) : (payload?.source?.id != null ? String(payload.source.id) : ''));
    return [evt, id, ab, k, s].join('|');
  }
  function dedupe(evt, payload, winMs){
    const now = Date.now();
    const sig = sigOf(evt, payload);
    const last = seen.get(sig) || 0;
    if (now - last < (winMs||400)) return true;
    seen.set(sig, now);
    if (seen.size > 200){
      for (const [k,t] of seen){
        if (now - t > 5000) seen.delete(k);
      }
    }
    return false;
  }

  function handle(evt, payload){
    try{
      const key = pickVoiceKey(payload);
      if (!key) return;
      if (dedupe(evt, payload, 350)) return;
      // Triple attempt to ride over render ticks
      [0,160,380].forEach((delay)=> setTimeout(()=> playLocal(key), delay));
    }catch(_){}
  }

  function attach(){
    const s = window.socket;
    if (!s || typeof s.on !== 'function') return false;

    // Canonical names
    ['abilityUsed','ability-used','server:abilityUsed','server:ability-used'].forEach(function(evt){
      try{ s.on(evt, (payload)=> handle(evt, payload)); }catch(_){}
    });

    // onAny fallback
    try{
      if (typeof s.onAny === 'function'){
        s.onAny(function(evt, payload){
          if (!evt || String(evt).toLowerCase().indexOf('ability') === -1) return;
          handle(evt, payload);
        });
      }
    }catch(_){}

    return true;
  }

  // Wait until socket exists
  if (!attach()){
    let tries = 0;
    const iv = setInterval(function(){
      tries++;
      if (attach() || tries > 140){ // ~7s
        clearInterval(iv);
      }
    }, 50);
  }
})();
</script>


<!-- CN_DB_STATE_CORRELATOR -->
<script>
(function(){
  const TAG='[DB-STATE]';
  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
  function play(key){
    try{ if (typeof window.playVoice === 'function') window.playVoice(key); }catch(_){}
  }
  function isDBId(id){
    try{
      const cs = (window.charState && window.charState.get && window.charState.get(String(id))) || null;
      return !!(cs && norm(cs.name) === 'deathblossom');
    }catch(_){ return false; }
  }

  const lastAbility = { ts:0, sourceId:null, kind:'', isDB:false };
  const lastHP = new Map();
  let lastBlossomCount = 0;

  function markAbility(p){
    try{
      lastAbility.ts = Date.now();
      lastAbility.sourceId = (p && (p.sourceId != null ? String(p.sourceId) :
                                    p.source && p.source.id != null ? String(p.source.id) : null)) || null;
      lastAbility.kind = norm(p && (p.kind || (p.ability && (p.ability.kind || p.ability.type)) || p.type || ''));
      lastAbility.isDB = lastAbility.sourceId && isDBId(lastAbility.sourceId);
    }catch(_){}
  }

  function onAbilityUsed(payload){
    markAbility(payload);
    // If special from DB, play immediately (event-driven)
    if (lastAbility.isDB && lastAbility.kind === 'special'){
      play('DeathBlossom_HealingBlossom');
    }
  }

  function onFullState(full){
    try{
      const arr = (full && (full.blossomPinkWalls || full.blossomWalls || []) ) || [];
      const count = Array.isArray(arr) ? arr.length : 0;
      if (count > lastBlossomCount){
        // New blossoms appeared; if recent DB ability, ensure playback
        if (Date.now() - lastAbility.ts < 2000 && lastAbility.isDB){
          play('DeathBlossom_HealingBlossom');
        }
      }
      lastBlossomCount = count;
      // Also seed HP map from full.hp if present
      if (full && full.hp){
        try{ Object.entries(full.hp).forEach(([id,hp])=> lastHP.set(String(id), Number(hp))); }catch(_){}
      }
    }catch(_){}
  }

  function onHPUpdate(p){
    try{
      const id = String(p && p.id || '');
      const hp = Number(p && p.hp);
      if (!id) return;
      const prev = lastHP.has(id) ? Number(lastHP.get(id)) : null;
      lastHP.set(id, hp);
      if (prev != null && hp > prev){
        // Someone healed. If DB used an ability very recently, assume it's Nectar of Life.
        if (Date.now() - lastAbility.ts < 1500 && lastAbility.isDB){
          play('NectarOfLife');
        }
      }
    }catch(_){}
  }

  function attach(){
    const s = window.socket;
    if (!s || typeof s.on !== 'function') return false;
    try{ s.on('abilityUsed', onAbilityUsed); }catch(_){}
    try{ s.on('fullState', onFullState); }catch(_){}
    try{ s.on('hpUpdate', onHPUpdate); }catch(_){}
    try{ s.on('nextTurn', function(){ lastBlossomCount = 0; }); }catch(_){}
    return true;
  }

  if (!attach()){
    let tries = 0;
    const iv = setInterval(function(){
      tries++;
      if (attach() || tries > 160) clearInterval(iv);
    }, 50);
  }
})();
</script>
\n



<!-- CN_DISCARD_VOICELINES -->
<script>
(function(){
  if (window.__CN_WRAP_RENDER_DISCARD) return;
  window.__CN_WRAP_RENDER_DISCARD = true;

  // Global dedupe for Healing Blossom across ALL callers (1s window)
  (function installHBDedupe(){
    try{
      if (window.__HB_DEDUPE_INSTALLED) return;
      window.__HB_DEDUPE_INSTALLED = true;
      const orig = window.playVoice;
      if (typeof orig === 'function'){
        let lastHB = 0;
        window.playVoice = function(key){
          try{
            const k = String(key||'');
            if (k === 'DeathBlossom_HealingBlossom' || k === 'DeathBlossom_HealingBlossom_Ability'){
              const now = Date.now();
              if (now - lastHB < 1000) return; // suppress rapid duplicates
              lastHB = now;
            }
          }catch(_){}
          return orig.apply(this, arguments);
        };
      }
    }catch(_){}
  })();

  function norm(x){ return String(x||'').toLowerCase().replace(/[\s_\-]+/g,''); }
  const _memo = {};
  function playOnce(key, ms){
    const now = Date.now();
    const win = ms || 350;
    if (_memo[key] && now - _memo[key] < win) return;
    _memo[key] = now;
    try{ if (typeof window.playVoice === 'function') window.playVoice(key); }catch(_){}
  }

  // Track last-seen card per discard slot so we only fire when it CHANGES
  const lastSeenBySlot = new WeakMap();

  try{
    const orig = window.renderDiscard || renderDiscard;
    if (typeof orig === 'function'){
      window.__origRenderDiscard = orig;
      window.renderDiscard = function(slotEl, type){
        const ret = orig.apply(this, arguments);
        try{
          let cur = '';
          if (type) {
            cur = norm(type);
          } else if (slotEl && slotEl.querySelector) {
            const img = slotEl.querySelector('img.discardImg, img');
            cur = norm(img && img.alt);
          }

          const prev = lastSeenBySlot.has(slotEl) ? lastSeenBySlot.get(slotEl) : '';
          if (cur !== prev){
            lastSeenBySlot.set(slotEl, cur || '');
            if (cur === 'nectaroflife' || cur === 'mend'){
              playOnce('NectarOfLife', 350);
            } else if (cur === 'healingblossom' || cur === 'healingbloom' || cur === 'blossom'){
              playOnce('DeathBlossom_HealingBlossom', 350);
            }
          } else if (!lastSeenBySlot.has(slotEl)) {
            // Initialize without playing
            lastSeenBySlot.set(slotEl, cur || '');
          }
        }catch(_){}
        return ret;
      };
    }
  }catch(_){}
})();
</script>





<script>
// --- Global Healing Blossom spawn VO v3 (added by ChatGPT) ---
(function(){
  try{
    if (window.__HB_VO_OBS3) return;
    window.__HB_VO_OBS3 = true;

    // Safety alias so the key resolves
    try { VOICES.HealingBlossom = VOICES.HealingBlossom || VOICES.DeathBlossom_HealingBlossom; } catch (_){}

    function _norm(s){ return String(s||'').toLowerCase().replace(/[\s_]+/g,''); }
    function _isHBName(n){ n=_norm(n); return n==='healingblossom'||n==='healingbloom'||n==='blossomwall'; }

    function _currentHBCount(){
      let count = 0;
      try{
        // Any explicit card elements by data-card name
        const cards = document.querySelectorAll('[data-card]');
        cards.forEach(el=>{ if (_isHBName(el.dataset.card)) count++; });

        // Any IMG elements referencing Healing_Blossom.png
        const imgs = document.querySelectorAll('img');
        imgs.forEach(img=>{
          const src = img.getAttribute('src') || img.src || '';
          if (/\bHealing_Blossom\.png\b/i.test(src)) count++;
        });
      }catch(_){}
      return count;
    }

    let prev = _currentHBCount();
    let timer = null;

    function scheduleCheck(){
      if (timer) clearTimeout(timer);
      // Debounce to wait for DOM to settle after moves/animations
      timer = setTimeout(()=>{
        try{
          const now = _currentHBCount();
          if (now > prev){
            if (typeof window.playVoice === 'function'){
              window.playVoice('HealingBlossom');
            }
          }
          prev = now; // update either way
        }catch(_){}
      }, 120);
    }

    const obs = new MutationObserver((muts)=>{
      // We don't inspect each mutation; just schedule a consolidated check
      scheduleCheck();
    });

    obs.observe(document.documentElement || document.body, {
      subtree: true,
      childList: true,
      attributes: true,
      // Tight scope: only these attrs could convert a node into an HB image/card
      attributeFilter: ['src','data-card']
    });

    // Initialize baseline after load
    scheduleCheck();

  }catch(_){}
})();
</script>

</body>
</html>

<style id="trap-caught-override">
  /* FINAL override to guarantee caught image is on top and visible */
  #trapCaughtLayer{ position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index: 9999 !important; }
  .trap-caught{
    position:absolute; width:104px; height:104px;
    margin-left:-52px; margin-top:-52px;
    background: url('/assets/Icons/BearTrapCaught.png') center/contain no-repeat;
    pointer-events:none; image-rendering:auto;
  }
</style>


<script id="trap-caught-final-handler">
(function(){
  // Ensure a dedicated, always-on-top overlay layer exists
  function ensureTrapCaughtLayer(){
    var board = document.getElementById('board') || document.body;
    var layer = document.getElementById('trapCaughtLayer');
    if (!layer){
      layer = document.createElement('div');
      layer.id = 'trapCaughtLayer';
      layer.style.position = 'absolute';
      layer.style.left = '0'; layer.style.top = '0';
      layer.style.right = '0'; layer.style.bottom = '0';
      layer.style.pointerEvents = 'none';
      layer.style.zIndex = '10000';
      board.appendChild(layer);
    }
    return layer;
  }

  // Optional helper if tile -> screen conversion exists on window
  function getTileScreenXY(tileId){
    try{
      var pos = (window.tilePositions||{})[String(tileId)];
      if (pos && typeof window.toScreen === 'function'){
        var s = window.toScreen(pos.x, pos.y);
        return {x:s.x, y:s.y};
      }
    }catch(_){}
    return null;
  }

  // Create / place the topmost BearTrapCaught sprite
  function BT_showCaughtAt(tileId){
    tileId = String(tileId);
    var layer = ensureTrapCaughtLayer();
    if (!layer) return;

    try{
      if (window.trapCaughtOverlays && window.trapCaughtOverlays.has(tileId)) return;
    }catch(_){}

    var xy = getTileScreenXY(tileId);
    if (!xy){
      // fallback: try a DOM tile element
      var cell = document.querySelector('[data-tile="'+tileId+'"]') || document.getElementById('tile-'+tileId);
      if (cell){
        var rect = cell.getBoundingClientRect();
        var hostRect = (layer.parentElement || document.body).getBoundingClientRect();
        xy = { x: (rect.left - hostRect.left) + rect.width/2, y: (rect.top - hostRect.top) + rect.height/2 };
      }
    }

    var img = document.createElement('img');
    img.className = 'bt-caught-img';
    img.src = '/assets/Icons/BearTrapCaught.png';
    img.alt = 'Trap triggered';
    img.draggable = false;
    img.style.position = 'absolute';
    img.style.width = '104px'; img.style.height = '104px';
    img.style.marginLeft = '-52px'; img.style.marginTop = '-52px';
    if (xy){ img.style.left = xy.x + 'px'; img.style.top = xy.y + 'px'; }
    layer.appendChild(img);

    try{ (window.trapCaughtOverlays = window.trapCaughtOverlays || new Map()).set(tileId, img); }catch(_){}
  }

  function bind(){
    if (window.__BT_TRAP_CAUGHT_BOUND__) return;
    window.__BT_TRAP_CAUGHT_BOUND__ = true;
    if (window.socket && typeof window.socket.on === 'function'){
      window.socket.on('trapTriggered', function(payload){
        try{
          if (payload && payload.tile != null) BT_showCaughtAt(String(payload.tile));
        }catch(_){}
      });
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind, {once:true});
  } else {
    bind();
  }
})();
</script>

<style id="trap-caught-override-2">
  #trapCaughtLayer{ position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index: 10000 !important; }
  img.bt-caught-img{ pointer-events:none; image-rendering:auto; z-index: 10001; }
</style>
